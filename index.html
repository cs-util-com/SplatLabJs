<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>3D Gaussian Splat Viewer - Multiple Scenes</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
        background-color: #000; /* Default background for Three.js */
        overflow: hidden; /* Prevent scrollbars */
    }
    #renderer-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0; /* Behind the UI panel */
        cursor: crosshair; /* Indicate interaction possibility */
    }
    #container {
        position: absolute; /* Changed from relative */
        top: 10px; /* Position from top */
        left: 10px; /* Position from left */
        z-index: 1; /* Above the renderer */
        pointer-events: none; /* Allow clicks to pass through container */
    }
    #view-panel {
        pointer-events: auto; /* Re-enable pointer events for the panel itself */
        background-color: rgba(243, 244, 246, 0.9); /* bg-gray-100 with opacity */
        display: inline-block; /* Make panel fit content */
    }
    /* Minimal styles for loading icon if needed before Tailwind loads or for custom animations */
    .loading-icon {
        width: 35px;
        margin: 10px auto;
        background: #324d70; /* Tailwind bg-blue-800 */
        aspect-ratio: 1;
        border-radius: 50%;
        --_m:
            conic-gradient(#0000,#000),
            linear-gradient(#000 0 0) content-box;
        -webkit-mask: var(--_m);
            mask: var(--_m);
        -webkit-mask-composite: source-out;
            mask-composite: subtract;
        box-sizing: border-box;
        animation: ply-load 1s linear infinite;
    }

    @keyframes ply-load {
        to{transform: rotate(1turn)}
    }
    .file-ext, .file-ext-small {
        border: 1px solid #bababa; /* Tailwind border-gray-300 */
        border-radius: 3px; /* Tailwind rounded-sm */
        background-color: #e6e6e6; /* Tailwind bg-gray-200 */
        padding: 1px 4px;
        margin: 0 2px;
        font-size: 0.875rem; /* Tailwind text-sm */
        display: inline-block;
    }
    .file-ext-small {
         background-color: #dfdfdf; /* Tailwind bg-gray-100 */
         padding-bottom: 1px;
    }
    .measurement-label {
        color: white;
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 10px; /* Smaller font for labels */
        font-family: sans-serif;
        text-shadow: 1px 1px 2px black; /* Improve readability */
    }
  </style>
  <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "gaussian-splats-3d": "./lib/gaussian-splats-3d.module.js"
        }
    }
  </script>
</head>

<body class="h-screen m-0 font-sans text-base">
  <!-- UI Panel -->
  <div id="container"> <!-- Removed flex classes -->
    <div id ="view-panel" class="p-3 text-gray-900 rounded-lg border border-gray-300 w-auto text-center shadow-lg"> <!-- Adjusted padding, width, text-align -->
        <div class="flex flex-col space-y-2"> <!-- Use flex column for layout -->
            <label for="viewFile" class="inline-block" title="Load .ply, .ksplat, .splat, .spz">
                <span class="text-blue-800 border border-blue-300 bg-blue-100 hover:bg-blue-200 hover:border-blue-500 hover:text-blue-900 py-1 px-3 rounded-md shadow-md cursor-pointer mx-auto block w-full">Add .ply, .ksplat, .splat, .spz</span>
                <input type="file" id="viewFile" class="hidden" onchange="window.onFileChange(this)"> <!-- Removed fileNameLabelID argument -->
            </label>
            <div class="flex items-center justify-center space-x-3"> <!-- Flex row for inputs -->
                 <div class="flex items-center space-x-1">
                     <label for="alphaRemovalThresholdView" class="text-sm text-gray-600">Alpha (1-255):</label>
                     <input id="alphaRemovalThresholdView" type="text" class="border border-gray-400 bg-white p-1 rounded-md w-12 text-sm" value="1" placeholder="1-255">
                 </div>
                 <div class="flex items-center space-x-1">
                     <label for="viewSphericalHarmonicsDegree" class="text-sm text-gray-600">SH:</label>
                     <!-- Replace input with select -->
                     <select id="viewSphericalHarmonicsDegree" class="border border-gray-400 bg-white p-1 rounded-md text-sm appearance-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="padding-right: 1.5rem; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2020%2020%22%20fill%3D%22currentColor%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20d%3D%22M5.293%207.293a1%201%200%20011.414%200L10%2010.586l3.293-3.293a1%201%200%20111.414%201.414l-4%204a1%201%200%2001-1.414%200l-4-4a1%201%200%20010-1.414z%22%20clip-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1em 1em;">
                         <option value="0" selected>0</option>
                         <option value="1">1</option>
                         <option value="2">2</option>
                     </select>
                 </div>
            </div>
            <!-- Add Rotation Checkbox -->
            <div class="flex items-center justify-center space-x-1 mt-1">
                <input type="checkbox" id="rotateSplatCheckbox" class="form-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" checked>
                <label for="rotateSplatCheckbox" class="ml-2 text-sm text-gray-600">Rotate 180Â° (X-axis)</label>
            </div>
            <!-- Add Camera FOV Control -->
            <div class="flex items-center justify-center space-x-1 mt-1 border-t pt-2 border-gray-300">
                <label for="fovSlider" class="text-sm text-gray-600 whitespace-nowrap">FOV:</label>
                <input type="range" id="fovSlider" min="1" max="120" value="75" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 mx-2">
                <span id="fovValue" class="text-sm text-gray-600 w-8 text-right">75</span>
            </div>
            <!-- Add Background Color Control -->
            <div class="flex items-center justify-center space-x-1 mt-1">
                <label for="bgColorPicker" class="text-sm text-gray-600 whitespace-nowrap">BG:</label>
                <input type="color" id="bgColorPicker" value="#000000" class="h-6 w-full border border-gray-400 rounded cursor-pointer mx-2">
            </div>
            <!-- Measurement Controls (Keep for now, interaction might need adjustment) -->
            <div class="border-t pt-2 mt-2 border-gray-300 flex justify-center space-x-2">
                 <button id="clearPointsButton" class="text-xs bg-red-100 hover:bg-red-200 text-red-800 border border-red-300 hover:border-red-500 py-1 px-2 rounded shadow-sm">Clear Points</button>
                 <button id="clearMeasurementsButton" class="text-xs bg-yellow-100 hover:bg-yellow-200 text-yellow-800 border border-yellow-300 hover:border-yellow-500 py-1 px-2 rounded shadow-sm">Clear Measures</button>
            </div>
            <!-- Transform Mode Toggle Button -->
            <div class="border-t pt-2 mt-2 border-gray-300 flex justify-center">
                 <button id="toggleTransformModeButton" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-800 border border-gray-400 hover:border-gray-500 py-1 px-3 rounded shadow-sm w-full">Enable Transform</button>
            </div>
            <!-- Transform Mode Options (Initially Hidden) -->
            <div id="transformModeOptions" class="hidden mt-2 flex justify-center space-x-1">
                 <button id="setTranslateMode" title="Translate (W)" class="text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 border border-blue-300 hover:border-blue-500 py-1 px-2 rounded shadow-sm">Move (W) </button>
                 <button id="setRotateMode" title="Rotate (E)" class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 border border-gray-300 hover:border-gray-500 py-1 px-2 rounded shadow-sm">Rotate (E) </button>
                 <button id="setScaleMode" title="Scale (R)" class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 border border-gray-300 hover:border-gray-500 py-1 px-2 rounded shadow-sm">Scale (R) </button>
            </div>
            <!-- Added Scene List for Selection (Optional but helpful) -->
            <div id="sceneListContainer" class="border-t pt-2 mt-2 border-gray-300 max-h-40 overflow-y-auto">
                 <h4 class="text-sm font-semibold text-gray-700 mb-1 text-center">Loaded Scenes</h4>
                 <ul id="sceneList" class="text-xs text-gray-600 space-y-1">
                     <!-- Scene items will be added here -->
                 </ul>
            </div>
        </div>
    </div>
  </div>

  <!-- Three.js Renderer Container -->
  <div id="renderer-container"></div>

  <script type="module">
    import * as GaussianSplats3D from 'gaussian-splats-3d';
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    // DragControls removed as TransformControls is preferred for object manipulation
    // import { DragControls } from 'three/addons/controls/DragControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js'; // Import TransformControls

    let scene, camera, renderer, controls;
    // CHANGE: Store multiple viewers
    let splatViewers = []; // Array to hold multiple DropInViewer instances
    let splatViewerFiles = []; // Store corresponding file info
    let activeSplatViewer = null; // Keep track of the currently selected viewer

    // Add references for FOV controls
    let fovSlider, fovValueDisplay;
    // Add reference for background color picker
    let bgColorPicker;

    // Declare markerGroup here so it's accessible within initThree scope (if measurement kept)
    let markerGroup;
    // Add variable to store current mouse NDC (if measurement kept)
    const currentMouseNDC = new THREE.Vector2();
    let transformControls; // Declare TransformControls variable
    let transformModeActive = false; // State for transform mode
    let toggleTransformModeButton; // Reference to the button
    // Add references for transform mode options
    let transformModeOptionsContainer;
    let setTranslateModeButton, setRotateModeButton, setScaleModeButton;

    // --- Measurement Variables (Keep for now, interaction might need adjustment) ---
    let measurementState = 'idle'; // 'idle', 'measuring'
    let currentMeasurementSequence = []; // { point: THREE.Vector3, marker: THREE.Group, segmentLine?: THREE.Line, distanceLabel?: THREE.Sprite, areaLabel?: THREE.Sprite }
    let measurementGroup; // Group for lines and labels
    let previewLine = null;
    let measurementColors = [0xff00ff, 0x00ffff, 0xffff00, 0xffa500, 0x00ff7f, 0xadd8e6]; // Magenta, Cyan, Yellow, Orange, SpringGreen, LightBlue
    let measurementColorIndex = 0;
    let scaleFactor = 1.0; // 1 unit in Three.js = 1 unit in real world initially
    let currentAxisSnap = null; // null, 'x', 'y', 'z'

    // --- Scene List UI ---
    let sceneListElement;

    // --- Helper Function to Detach Gizmo ---
    function detachGizmo() {
        if (transformControls.object) {
            transformControls.detach();
            transformControls.visible = false;
            transformControls.enabled = false;
            if (activeSplatViewer) { // Deselect UI element if attached
                 updateSceneListSelection(null);
            }
            activeSplatViewer = null; // Deselect viewer logically
            console.log("Gizmo detached.");
        }
    }

    // --- Helper Function to Update Transform Button State ---
    function updateTransformButtonState() {
        if (transformModeActive) {
            toggleTransformModeButton.textContent = "Disable Transform";
            toggleTransformModeButton.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-800', 'border-gray-400', 'hover:border-gray-500');
            toggleTransformModeButton.classList.add('bg-green-200', 'hover:bg-green-300', 'text-green-900', 'border-green-400', 'hover:border-green-600');
        } else {
            toggleTransformModeButton.textContent = "Enable Transform";
            toggleTransformModeButton.classList.remove('bg-green-200', 'hover:bg-green-300', 'text-green-900', 'border-green-400', 'hover:border-green-600');
            toggleTransformModeButton.classList.add('bg-gray-200', 'hover:bg-gray-300', 'text-gray-800', 'border-gray-400', 'hover:border-gray-500');
        }
    }

    // --- Helper Function to Update Transform Mode Buttons Visual State ---
    function updateTransformModeButtons(activeMode) {
        const buttons = [setTranslateModeButton, setRotateModeButton, setScaleModeButton];
        const modes = ['translate', 'rotate', 'scale'];
        const activeClasses = ['bg-blue-200', 'border-blue-500', 'text-blue-900']; // Brighter active state
        const inactiveClasses = ['bg-gray-100', 'hover:bg-gray-200', 'text-gray-800', 'border-gray-300', 'hover:border-gray-500'];

        buttons.forEach((button, index) => {
            button.classList.remove(...activeClasses, ...inactiveClasses); // Clear previous styles
            if (modes[index] === activeMode) {
                button.classList.add(...activeClasses);
            } else {
                button.classList.add(...inactiveClasses);
            }
        });
    }


    // --- Helper Function to Deactivate Transform Mode ---
    function deactivateTransformMode() {
        if (transformModeActive) {
            transformModeActive = false;
            detachGizmo(); // Detach from any active viewer
            updateTransformButtonState();
            transformModeOptionsContainer.classList.add('hidden'); // Hide mode options
            console.log("Transform mode deactivated.");
        }
    }

    // --- Scene List UI Update ---
    function populateSceneList() {
        if (!sceneListElement) sceneListElement = document.getElementById('sceneList');
        sceneListElement.innerHTML = ''; // Clear existing list

        if (splatViewers.length === 0) {
             sceneListElement.innerHTML = '<li class="italic text-center text-gray-500">No scenes loaded</li>';
             return;
        }

        splatViewers.forEach((viewer, index) => {
            const fileInfo = splatViewerFiles[index];
            const li = document.createElement('li');
            li.textContent = `${index + 1}: ${fileInfo.name}`;
            li.dataset.sceneIndex = index; // Store index for click handling
            li.classList.add('p-1', 'border-b', 'border-gray-200', 'cursor-pointer', 'hover:bg-gray-100');
            li.addEventListener('click', handleSceneListItemClick);
            sceneListElement.appendChild(li);
        });
        updateSceneListSelection(activeSplatViewer); // Highlight if already selected
    }

    function handleSceneListItemClick(event) {
        const index = parseInt(event.target.dataset.sceneIndex);
        const clickedViewer = splatViewers[index];

        if (transformModeActive && clickedViewer) {
            if (activeSplatViewer !== clickedViewer) {
                detachGizmo(); // Detach from previous
                transformControls.attach(clickedViewer); // Attach to DropInViewer object
                transformControls.visible = true;
                transformControls.enabled = true;
                activeSplatViewer = clickedViewer;
                updateTransformModeButtons(transformControls.getMode());
                console.log(`Gizmo attached to scene #${index + 1} via list.`);
            } else {
                 // Clicked the already active scene, detach
                 detachGizmo();
            }
            updateSceneListSelection(activeSplatViewer);
        } else if (!transformModeActive) {
             console.log("Enable Transform mode first to select a scene.");
        }
    }

    // Highlight the selected item in the UI list
    function updateSceneListSelection(selectedViewer) {
        if (!sceneListElement) return;
        const items = sceneListElement.querySelectorAll('li');
        items.forEach(item => {
            const index = parseInt(item.dataset.sceneIndex);
            if (splatViewers[index] === selectedViewer) {
                item.classList.add('bg-blue-100', 'font-semibold');
                item.classList.remove('hover:bg-gray-100');
            } else {
                item.classList.remove('bg-blue-100', 'font-semibold');
                item.classList.add('hover:bg-gray-100');
            }
        });
    }


    function initThree() {
        const container = document.getElementById('renderer-container');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black

        // Camera
        const initialFov = 75; // Store initial FOV
        camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 5); // Adjusted initial position slightly
        camera.lookAt(0, 0, 0); // Look at origin

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Add pointermove listener (keep for measurement preview if needed)
        renderer.domElement.addEventListener('pointermove', onPointerMove, false);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Optional damping effect
        controls.target.set(0, 0, 0); // Set initial lookAt
        controls.update();

        // Axes Helper
        const axesHelper = new THREE.AxesHelper( 5 ); // Length of 5 units
        scene.add( axesHelper );

        // Grid Helper
        const size = 10; // Size of the grid (e.g., 10x10 units)
        const divisions = 10; // Number of divisions within the grid
        const gridHelper = new THREE.GridHelper( size, divisions );
        scene.add( gridHelper );

        // --- Marker Group Initialization (Keep ONLY if Measurement Points needed) ---
        markerGroup = new THREE.Group(); // Assign to the outer scope variable
        scene.add(markerGroup); // Add the group to the scene

        // --- Measurement Group Initialization (Keep if needed) ---
        measurementGroup = new THREE.Group();
        scene.add(measurementGroup);

        // --- Transform Controls Initialization ---
        transformControls = new TransformControls(camera, renderer.domElement);
        transformControls.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value; // Disable OrbitControls while dragging gizmo
        });
         // Add to scene once, detach/attach as needed
        scene.add(transformControls);
        transformControls.visible = false; // Initially hidden
        transformControls.enabled = false; // Initially disabled


        // Get FOV UI elements
        fovSlider = document.getElementById('fovSlider');
        fovValueDisplay = document.getElementById('fovValue');
        // Get Background Color Picker element
        bgColorPicker = document.getElementById('bgColorPicker');

        // Set initial FOV display
        fovValueDisplay.textContent = initialFov;
        fovSlider.value = initialFov;

        // Add FOV slider event listener
        fovSlider.addEventListener('input', () => {
            const newFov = parseInt(fovSlider.value);
            // Calculate distance adjustment to maintain apparent size at target
            const currentDistance = camera.position.distanceTo(controls.target);
            const currentFovRad = THREE.MathUtils.degToRad(camera.fov);
            const newFovRad = THREE.MathUtils.degToRad(newFov);
            // Avoid division by zero/very small numbers if tan(newFovRad / 2) is close to zero
            const tanNewFovHalf = Math.tan(newFovRad / 2);
            if (tanNewFovHalf > 1e-6) { // Check against a small epsilon
                const newDistance = currentDistance * (Math.tan(currentFovRad / 2) / tanNewFovHalf);
                // Calculate direction and new position
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                const newPosition = new THREE.Vector3().copy(controls.target).addScaledVector(direction, newDistance);
                // Update camera position first
                camera.position.copy(newPosition);
            } else {
                 console.warn("FOV too small, cannot adjust distance effectively.");
            }
            // Update camera FOV
            camera.fov = newFov;
            camera.updateProjectionMatrix();
            fovValueDisplay.textContent = newFov;
        });

        // Add Background Color Picker event listener
        bgColorPicker.addEventListener('input', (event) => {
            const newColor = event.target.value;
            scene.background = new THREE.Color(newColor);
        });

        // Get Transform Mode Button element
        toggleTransformModeButton = document.getElementById('toggleTransformModeButton');
        // Get Transform Mode Options elements
        transformModeOptionsContainer = document.getElementById('transformModeOptions');
        setTranslateModeButton = document.getElementById('setTranslateMode');
        setRotateModeButton = document.getElementById('setRotateMode');
        setScaleModeButton = document.getElementById('setScaleMode');


        // Add Transform Mode Button event listener
        toggleTransformModeButton.addEventListener('click', () => {
            transformModeActive = !transformModeActive; // Toggle the state
            updateTransformButtonState(); // Update button appearance
            if (!transformModeActive) {
                detachGizmo(); // Detach gizmo if disabling the mode
                transformModeOptionsContainer.classList.add('hidden'); // Hide mode options
                console.log("Transform mode disabled via button.");
            } else {
                transformModeOptionsContainer.classList.remove('hidden'); // Show mode options
                 if (activeSplatViewer) { // Update buttons only if something is selected
                     updateTransformModeButtons(transformControls.getMode());
                 } else {
                     // Maybe reset buttons to default appearance if nothing selected?
                     updateTransformModeButtons(null); // Reset button styles
                 }
                console.log("Transform mode enabled via button. Click a splat scene to activate gizmo.");
                 // Cancel measurement if enabling transform mode
                 if (measurementState === 'measuring') {
                     console.log("Transform mode enabled while measuring. Cancelling measurement.");
                     resetMeasurementState();
                 }
            }
        });

        // Add listeners for mode change buttons
        setTranslateModeButton.addEventListener('click', () => {
            if (transformModeActive && transformControls.object) {
                transformControls.setMode('translate');
                updateTransformModeButtons('translate');
            }
        });
        setRotateModeButton.addEventListener('click', () => {
            if (transformModeActive && transformControls.object) {
                transformControls.setMode('rotate');
                updateTransformModeButtons('rotate');
            }
        });
        setScaleModeButton.addEventListener('click', () => {
            if (transformModeActive && transformControls.object) {
                transformControls.setMode('scale');
                updateTransformModeButtons('scale');
            }
        });


        // --- DragControls REMOVED ---

        // --- Measurement Event Listeners (Keep for now) ---
        renderer.domElement.addEventListener('click', onClick, false); // Use click for measurement AND gizmo activation
        window.addEventListener('keydown', onKeyDown, false);
        document.getElementById('clearPointsButton').addEventListener('click', clearReferencePoints);
        document.getElementById('clearMeasurementsButton').addEventListener('click', clearMeasurements);

        // --- Scene List ---
        sceneListElement = document.getElementById('sceneList');
        populateSceneList(); // Initial population (will be empty)

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);

        // Start animation loop
        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update(); // Update controls
        // No specific viewer updates needed here if they are just Object3Ds
        renderer.render(scene, camera);
    }

    // Initialize Three.js setup on load
    initThree();

    // --- Splat Loading Logic ---

    // Pass SH degree to loaders that support it
    function fileBufferToSplatBuffer(fileBufferData, format, alphaRemovalThreshold, outSphericalHarmonicsDegree) {
      // ... (keep this function as is) ...
        const optimize = false;
        const compressionLevel = 0;
        // Use outSphericalHarmonicsDegree passed from UI
        if (format === GaussianSplats3D.SceneFormat.Ply) {
            return GaussianSplats3D.PlyLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, optimize, outSphericalHarmonicsDegree, undefined, undefined, undefined, undefined);
        } else if (format === GaussianSplats3D.SceneFormat.Splat) {
            // SplatLoader doesn't take SH degree as input, it's determined by the file
            return GaussianSplats3D.SplatLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, optimize, undefined, undefined, undefined, undefined);
        } else if (format === GaussianSplats3D.SceneFormat.KSplat) {
            // KSplatLoader doesn't take SH degree as input
            return GaussianSplats3D.KSplatLoader.loadFromFileData(fileBufferData.data);
        } else if (format === GaussianSplats3D.SceneFormat.Spz) {
            // SpzLoader takes SH degree as input
            return GaussianSplats3D.SpzLoader.loadFromFileData(fileBufferData.data, alphaRemovalThreshold, compressionLevel, optimize, outSphericalHarmonicsDegree, undefined, undefined, undefined, undefined);
        } else {
            return Promise.reject(`Unsupported file format: ${format}`);
        }
    }

    // CHANGE: Modified onFileChange to create new viewers
    window.onFileChange = function(arg) {
      const viewFile = document.getElementById("viewFile");
      if (!arg || !arg.files || arg.files.length === 0) return;

      const file = viewFile.files[0];
      const alphaRemovalThreshold = parseInt(document.getElementById("alphaRemovalThresholdView").value);
      const sphericalHarmonicsDegree = parseInt(document.getElementById("viewSphericalHarmonicsDegree").value);
      const rotateSplat = document.getElementById("rotateSplatCheckbox").checked;

      if (isNaN(alphaRemovalThreshold) || alphaRemovalThreshold < 0 || alphaRemovalThreshold > 255) {
          console.error("Invalid alpha removal threshold (0-255).");
          return;
      }

      const viewFileName = file.name.trim();
      const format = GaussianSplats3D.LoaderUtils.sceneFormatFromPath(viewFileName);
      if (format === undefined) {
          console.error("Could not determine file format. Ensure file has a .ply, .splat, .ksplat, or .spz extension.");
          return;
      }

      // Detach gizmo and deactivate mode before loading new splat data
      deactivateTransformMode();

      try {
        const fileReader = new FileReader();
        fileReader.onload = function(){
          console.log("Processing file...");
          setTimeout(() => { // Keep setTimeout for UI responsiveness during parse
              try {
                const splatBufferPromise = fileBufferToSplatBuffer({data: fileReader.result}, format, alphaRemovalThreshold, sphericalHarmonicsDegree);

                splatBufferPromise.then((splatBuffer) => {
                    // --- CREATE NEW VIEWER ---
                    const newDropInViewer = new GaussianSplats3D.DropInViewer({
                         'sharedMemoryForWorkers': false, // May need tuning for multiple workers
                         'gpuAcceleratedSort': false,     // May need tuning for multiple viewers
                         'sphericalHarmonicsDegree': sphericalHarmonicsDegree // Use selected degree
                    });

                    const splatBufferOptions = {
                        'splatAlphaRemovalThreshold': alphaRemovalThreshold,
                    };

                    // Add the buffer to the NEW viewer instance, REPLACING anything hypothetically there
                    newDropInViewer.viewer.addSplatBuffers([splatBuffer], [splatBufferOptions], true, true /* replaceExisting */, false, false)
                        .then(() => {
                            console.log(`Splat buffer added to new viewer instance.`);

                            // Apply rotation to the DropInViewer object itself if checked
                            if (rotateSplat) {
                                newDropInViewer.rotation.x += Math.PI; // Add 180 degrees (PI radians) to X-axis
                                console.log("Rotation applied to new viewer object.");
                            }

                            // Add the new viewer to the scene and our collections
                            scene.add(newDropInViewer);
                            splatViewers.push(newDropInViewer);
                            splatViewerFiles.push({ name: file.name, size: file.size }); // Store file info
                            console.log(`Added viewer #${splatViewers.length} ('${file.name}') to scene.`);
                            populateSceneList(); // Update the UI list

                        })
                        .catch((e) => {
                            console.error("Error adding splat buffer to new viewer:", e);
                            // Clean up the partially created viewer if add fails
                            scene.remove(newDropInViewer); // Remove from scene
                        });
                })
                .catch((e) => {
                    console.error("Error creating splat buffer:", e);
                });
              } catch (e) {
                console.error("Could not process scene: " + e.message);
              }
          }, 10);
        }
        fileReader.onerror = function() { console.error("Error reading file."); }
        console.log("Loading file...");
        fileReader.readAsArrayBuffer(file);
      } catch (e) {
        console.error("Could not load scene: " + e.message);
      }
    }

    // --- Click-to-Spawn Reference Point Feature (Keep for now, interaction might need adjustment) ---
    // --- Define materials and geometry for the cross marker ---
    const baseCrossSize = 0.2; // Base size of the cross arms at reference distance
    const crossThicknessRatio = 0.1; // Thickness relative to size
    const crossMaterialX = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red for X
    const crossMaterialY = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green for Y
    const crossMaterialZ = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue for Z

    // Function to create a cross marker (Reference Point)
    function createCrossMarkerAtPosition(position, cameraPosition) {
        // ... (keep this function as is) ...
         const distance = position.distanceTo(cameraPosition);
         const referenceDistance = 5.0;
         const scaleFactor = (distance / referenceDistance);
         const currentCrossSize = baseCrossSize * scaleFactor;
         const currentCrossThickness = currentCrossSize * crossThicknessRatio;
         const dynamicCrossGeometryX = new THREE.BoxGeometry(currentCrossSize, currentCrossThickness, currentCrossThickness);
         const dynamicCrossGeometryY = new THREE.BoxGeometry(currentCrossThickness, currentCrossSize, currentCrossThickness);
         const dynamicCrossGeometryZ = new THREE.BoxGeometry(currentCrossThickness, currentCrossThickness, currentCrossSize);
         const crossGroup = new THREE.Group();
         const crossMeshX = new THREE.Mesh(dynamicCrossGeometryX, crossMaterialX);
         crossMeshX.name = 'crossX';
         const crossMeshY = new THREE.Mesh(dynamicCrossGeometryY, crossMaterialY);
         crossMeshY.name = 'crossY';
         const crossMeshZ = new THREE.Mesh(dynamicCrossGeometryZ, crossMaterialZ);
         crossMeshZ.name = 'crossZ';
         crossGroup.add(crossMeshX);
         crossGroup.add(crossMeshY);
         crossGroup.add(crossMeshZ);
         crossGroup.position.copy(position);
         crossGroup.userData.isReferencePoint = true;
         crossGroup.userData.originalPosition = position.clone();
         markerGroup.add(crossGroup);
         console.log(`Reference Point added at: ${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}`);
         dynamicCrossGeometryX.dispose();
         dynamicCrossGeometryY.dispose();
         dynamicCrossGeometryZ.dispose();
    }

    // --- Raycaster Setup and Event Handling ---
    const outHits = []; // Reusable array for hits from a single viewer
    const allOutHits = []; // To collect hits from ALL viewers per click
    const renderDimensions = new THREE.Vector2();
    const clickRaycaster = new THREE.Raycaster(); // Use a separate raycaster for clicks
    clickRaycaster.params.Line.threshold = 0.1; // Adjust threshold for clicking lines
    clickRaycaster.params.Points.threshold = 0.1; // If needed for points

    // --- Double Click Listener (Keep for placing points ONLY) ---
    renderer.domElement.addEventListener('dblclick', onDoubleClick, false);

    function onDoubleClick(event) {
        // ... (keep this function as is, but note it raycasts against all viewers now) ...
         event.preventDefault();
         const containerRect = document.getElementById('container').getBoundingClientRect();
         if (event.clientX >= containerRect.left && event.clientX <= containerRect.right &&
             event.clientY >= containerRect.top && event.clientY <= containerRect.bottom) {
             return; // Click is inside the UI panel
         }

         const mouse = new THREE.Vector2(
             (event.clientX / window.innerWidth) * 2 - 1,
             -(event.clientY / window.innerHeight) * 2 + 1
         );
         clickRaycaster.setFromCamera(mouse, camera);
         const intersectsMarkers = clickRaycaster.intersectObjects(markerGroup.children, true);

         if (intersectsMarkers.length > 0) {
             const intersectedObject = intersectsMarkers[0].object;
             if (intersectedObject.parent && intersectedObject.parent.userData.isReferencePoint) {
                 const crossToRemove = intersectedObject.parent;
                 markerGroup.remove(crossToRemove);
                 // cleanupMeasurementsForPoint(crossToRemove); // Consider if needed
                 console.log("Reference Point removed by double-click.");
                 return;
             }
         }

         // Raycast against ALL viewers to find where to place the point
         let closestHitPosition = null;
         let minHitDistance = Infinity;

         for (const viewer of splatViewers) {
             const internalRaycaster = viewer?.viewer?.raycaster;
             const splatMesh = viewer?.viewer?.splatMesh;

             if (!internalRaycaster || !splatMesh || splatMesh.getSplatCount() === 0) continue;

             const rect = renderer.domElement.getBoundingClientRect();
             const screenPosition = new THREE.Vector2(event.clientX - rect.left, event.clientY - rect.top);
             renderer.getSize(renderDimensions);
             outHits.length = 0;

             internalRaycaster.ray = clickRaycaster.ray; // Use main ray
             internalRaycaster.intersectSplatMesh(splatMesh, outHits);

             if (outHits.length > 0 && outHits[0].distance < minHitDistance) {
                 minHitDistance = outHits[0].distance;
                 closestHitPosition = outHits[0].origin; // Store world-space hit position
             }
         }

         if (closestHitPosition) {
             createCrossMarkerAtPosition(closestHitPosition, camera.position);
         } else {
             console.log("No splat hit on double-click.");
         }
    }

    // --- Click Listener (Refactored for Gizmo Activation on MULTIPLE Viewers) ---
    function onClick(event) {
        event.preventDefault();
        // console.log(`onClick triggered. Transform Mode: ${transformModeActive}, Measurement State: ${measurementState}`);

        // 1. Ignore if dragging gizmo
        if (transformControls.dragging) {
            console.log("onClick ignored: Gizmo drag in progress.");
            return;
        }

        // 2. Ignore if clicking UI panel
        const containerRect = document.getElementById('container').getBoundingClientRect();
        if (event.clientX >= containerRect.left && event.clientX <= containerRect.right &&
            event.clientY >= containerRect.top && event.clientY <= containerRect.bottom) {
            console.log("onClick ignored: UI panel.");
            return; // Click is inside the UI panel
        }

        // --- Raycasting Setup ---
        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );
        clickRaycaster.setFromCamera(mouse, camera); // Use the main raycaster


        // --- Interaction Checks (Prioritized) ---

        // 3. Check Label Click (Scaling) - Adapt if measurements kept
        let labelHit = false;
        if (measurementState === 'idle') {
            const intersectsLabels = clickRaycaster.intersectObjects(measurementGroup.children, true)
                .filter(intersect => intersect.object.userData && intersect.object.userData.isDistanceLabel);
            if (intersectsLabels.length > 0) {
                labelHit = true;
                console.log("onClick: Label clicked.");
                setReferenceScale(intersectsLabels[0].object);
                deactivateTransformMode(); // Deactivate transform mode if a label is clicked
                return; // Label click handled
            }
        }
        // console.log(`onClick: Label hit? ${labelHit} (State: ${measurementState})`);

        // 4. Check Marker Click (Measurement Start/Continue) - Adapt if measurements kept
        const intersectsMarkers = clickRaycaster.intersectObjects(markerGroup.children, true);
        let clickedMarker = null;
        if (intersectsMarkers.length > 0) {
            let obj = intersectsMarkers[0].object;
            while (obj && !obj.userData.isReferencePoint) {
                obj = obj.parent;
            }
            if (obj && obj.userData.isReferencePoint) {
                clickedMarker = obj;
            }
        }
        // console.log(`onClick: Marker hit? ${!!clickedMarker}`);

        if (clickedMarker) {
            // console.log("onClick: Marker interaction.");
            if (measurementState === 'idle') {
                startMeasurement(clickedMarker);
                deactivateTransformMode(); // Deactivate transform mode when starting measurement
            } else if (measurementState === 'measuring') {
                addPointToMeasurement(clickedMarker);
            }
            return; // Marker click handled
        }

        // --- If not label or marker, check splat or empty space ---

        // 5. Check Splat Click (Gizmo Activation / Measurement Cancel)
        allOutHits.length = 0; // Clear combined hits
        let hitViewer = null;
        let closestHitDistance = Infinity;

        // Iterate through all viewers
        for (let i = 0; i < splatViewers.length; i++) {
            const viewer = splatViewers[i];
            const internalRaycaster = viewer?.viewer?.raycaster;
            const splatMesh = viewer?.viewer?.splatMesh;

            if (!internalRaycaster || !splatMesh || splatMesh.getSplatCount() === 0) {
                continue; // Skip this viewer if no splats or raycaster
            }

            const currentViewerHits = []; // Temp storage for this viewer's hits

            // Use the *viewer's* internal intersectSplatMesh method, passing the *main camera's* ray
            internalRaycaster.ray = clickRaycaster.ray; // Set the ray for the internal raycaster
            internalRaycaster.intersectSplatMesh(splatMesh, currentViewerHits);

            if (currentViewerHits.length > 0) {
                // Find the closest hit *for this viewer* (intersectSplatMesh usually sorts by distance)
                let closestViewerHit = currentViewerHits[0];
                if (closestViewerHit.distance < closestHitDistance) {
                    closestHitDistance = closestViewerHit.distance;
                    hitViewer = viewer; // Store the viewer that had the closest hit overall
                }
            }
        }
        // console.log(`onClick: Splat hit? ${!!hitViewer}`);

        if (hitViewer) { // If any viewer was hit
            // console.log("onClick: Splat interaction on viewer:", hitViewer);

            // Cancel measurement if it was active
            if (measurementState === 'measuring') {
                console.log("onClick: Splat clicked while measuring. Cancelling measurement.");
                resetMeasurementState(); // Cancel measurement
            }

            // Only attach gizmo if transform mode is active
            if (transformModeActive) {
                const shouldAttach = activeSplatViewer !== hitViewer; // Attach if different or none selected
                // console.log(`onClick: Should attach gizmo (Transform Mode Active)? ${shouldAttach}`);

                if (shouldAttach) {
                    detachGizmo(); // Detach from previous, if any
                    // Attach to the DropInViewer object itself
                    transformControls.attach(hitViewer);
                    transformControls.visible = true;
                    transformControls.enabled = true;
                    activeSplatViewer = hitViewer; // Set the active viewer
                    updateTransformModeButtons(transformControls.getMode()); // Update buttons on attach
                    updateSceneListSelection(activeSplatViewer); // Highlight in list
                    console.log("onClick: Gizmo attached to selected splat viewer.");
                }
                // If already attached to this viewer, clicking its splats again does nothing (keeps it attached)
            } else {
                 console.log("onClick: Splat clicked, but Transform Mode is not active. Gizmo not attached.");
            }
            return; // Splat click handled
        }

        // 6. Clicked on Empty Space (Gizmo Detach / Measurement Cancel)
        // console.log("onClick: Empty space interaction.");
        if (measurementState === 'measuring') {
            console.log("onClick: Empty space clicked while measuring. Cancelling measurement.");
            resetMeasurementState(); // Cancel measurement
        }
        deactivateTransformMode(); // Detach gizmo AND deactivate mode
        updateSceneListSelection(null); // Deselect in list
    }


    // --- Pointer Move Listener (Adapt if used for measurement preview) ---
    function onPointerMove(event) {
        // Update NDC (keep if needed for measurements)
        currentMouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
        currentMouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Update measurement preview logic if needed...
        // (May need to raycast against markers more carefully)
        if (measurementState === 'measuring' && currentMeasurementSequence.length > 0) {
            clickRaycaster.setFromCamera(currentMouseNDC, camera);
            const intersectsMarkers = clickRaycaster.intersectObjects(markerGroup.children, true);

            let hoveredMarker = null;
            if (intersectsMarkers.length > 0) {
                let obj = intersectsMarkers[0].object;
                while (obj && !obj.userData.isReferencePoint) obj = obj.parent;
                if (obj && obj.userData.isReferencePoint && obj !== currentMeasurementSequence[currentMeasurementSequence.length - 1].marker) {
                    hoveredMarker = obj;
                }
            }

            if (hoveredMarker) updatePreviewLine(hoveredMarker.position);
            else updatePreviewLine(null);
        } else {
             updatePreviewLine(null);
        }
    }

    // --- Key Down Listener (Keep gizmo controls) ---
    function onKeyDown(event) {
        // Handle gizmo controls if it's attached AND transform mode is active
        // NOTE: transformControls.object will now be the DropInViewer instance
        if (transformControls.object && transformModeActive) {
             let newMode = null;
            switch (event.key.toLowerCase()) {
                case 'w': // Translate
                    transformControls.setMode("translate");
                    newMode = 'translate';
                    event.preventDefault();
                    break;
                case 'e': // Rotate
                    transformControls.setMode("rotate");
                    newMode = 'rotate';
                    event.preventDefault();
                    break;
                case 'r': // Scale
                    transformControls.setMode("scale");
                    newMode = 'scale';
                    event.preventDefault();
                    break;
                case 'q': // Toggle World/Local Space
                    transformControls.setSpace(transformControls.space === "local" ? "world" : "local");
                    event.preventDefault();
                    break;
                case 'escape': // Detach Gizmo AND Deactivate Mode
                     // Only act if not measuring
                     if (measurementState === 'idle') {
                         deactivateTransformMode(); // Use helper function
                         event.preventDefault();
                     }
                    break;
            }
            if (newMode) {
                updateTransformModeButtons(newMode); // Update buttons on keyboard mode change
            }
        }

        // Handle measurement controls if measuring
        if (measurementState === 'measuring') {
            // ... (keep measurement key handling as is) ...
            switch (event.key) {
                case 'Enter':
                case 'Escape': // ESC also finishes measurement
                    finishMeasurement(false); // Finish as open path
                    event.preventDefault();
                    break;
                case 'Backspace':
                case 'Delete':
                    removeLastMeasurementSegment();
                    event.preventDefault();
                    break;
                case 'ArrowLeft':
                    currentAxisSnap = 'x';
                    updatePreviewLine();
                    event.preventDefault();
                    break;
                case 'ArrowRight':
                    currentAxisSnap = 'z';
                    updatePreviewLine();
                    event.preventDefault();
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    currentAxisSnap = 'y';
                    updatePreviewLine();
                    event.preventDefault();
                    break;
            }
        }
    }

    // --- Measurement Core Functions (Keep for now, interaction might need adjustment) ---
    function startMeasurement(startMarker) {
        // ... (keep as is) ...
         if (measurementState !== 'idle') return;
         measurementState = 'measuring';
         currentMeasurementSequence = [{ point: startMarker.position.clone(), marker: startMarker }];
         measurementColorIndex = (measurementColorIndex + 1) % measurementColors.length;
         currentAxisSnap = null;
         console.log("Started measurement sequence.");
         updatePreviewLine();
    }

    function addPointToMeasurement(nextMarker) {
        // ... (keep as is) ...
         if (measurementState !== 'measuring' || currentMeasurementSequence.length === 0) return;
         const startPointInfo = currentMeasurementSequence[currentMeasurementSequence.length - 1];
         const endPoint = nextMarker.position.clone();
         const startPoint = startPointInfo.point;
         if (currentMeasurementSequence.length >= 2 && nextMarker === currentMeasurementSequence[0].marker) {
             drawMeasurementSegment(startPoint, currentMeasurementSequence[0].point, currentMeasurementSequence[0].marker);
             finishMeasurement(true);
             return;
         }
         if (nextMarker === startPointInfo.marker) {
             console.log("Cannot add the same point consecutively.");
             return;
         }
         drawMeasurementSegment(startPoint, endPoint, nextMarker);
         if (!currentAxisSnap) {
              currentMeasurementSequence.push({ point: endPoint, marker: nextMarker });
         }
         currentAxisSnap = null;
         updatePreviewLine();
    }

    function drawMeasurementSegment(p1, p2, endMarker) {
        // ... (keep as is) ...
         const color = measurementColors[measurementColorIndex];
         let segments = [];
         if (currentAxisSnap) {
             let intermediatePoints = [p1.clone()];
             let current = p1.clone();
             const target = p2.clone();
             if (currentAxisSnap === 'x') {
                 let p = current.clone(); p.x = target.x;
                 if (p.distanceToSquared(current) > 1e-6) intermediatePoints.push(p.clone());
                 p.y = target.y;
                 if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) intermediatePoints.push(p.clone());
                 p.z = target.z;
                 if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) intermediatePoints.push(p.clone());
             } else if (currentAxisSnap === 'y') {
                 let p = current.clone(); p.y = target.y;
                 if (p.distanceToSquared(current) > 1e-6) intermediatePoints.push(p.clone());
                 p.x = target.x;
                 if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) intermediatePoints.push(p.clone());
                 p.z = target.z;
                 if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) intermediatePoints.push(p.clone());
             } else if (currentAxisSnap === 'z') {
                 let p = current.clone(); p.z = target.z;
                 if (p.distanceToSquared(current) > 1e-6) intermediatePoints.push(p.clone());
                 p.x = target.x;
                 if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) intermediatePoints.push(p.clone());
                 p.y = target.y;
                 if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) intermediatePoints.push(p.clone());
             }
             for (let i = 0; i < intermediatePoints.length - 1; i++) {
                 segments.push({ start: intermediatePoints[i], end: intermediatePoints[i+1] });
             }
             for (let i = 1; i < intermediatePoints.length; i++) {
                  const markerForPoint = (i === intermediatePoints.length - 1) ? endMarker : null;
                  currentMeasurementSequence.push({ point: intermediatePoints[i], marker: markerForPoint });
             }
         } else {
             segments.push({ start: p1, end: p2 });
         }
         segments.forEach(seg => {
             const distance = seg.start.distanceTo(seg.end) * scaleFactor;
             if (distance < 1e-6) return;
             const geometry = new THREE.BufferGeometry().setFromPoints([seg.start, seg.end]);
             const material = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
             const line = new THREE.Line(geometry, material);
             line.userData.isMeasurementLine = true;
             line.userData.colorIndex = measurementColorIndex;
             measurementGroup.add(line);
             const label = createDistanceLabel(distance.toFixed(2), color);
             label.position.copy(seg.start).lerp(seg.end, 0.5);
             label.userData.isDistanceLabel = true;
             label.userData.segmentStart = seg.start.clone();
             label.userData.segmentEnd = seg.end.clone();
             label.userData.colorIndex = measurementColorIndex;
             measurementGroup.add(label);
              const sequenceEntry = currentMeasurementSequence.find(entry => entry.point.equals(seg.start));
              if (sequenceEntry) {
                  if (!sequenceEntry.segments) sequenceEntry.segments = [];
                  sequenceEntry.segments.push({ line: line, label: label });
              } else {
                  console.warn("Could not find sequence entry for segment start:", seg.start);
                  const lastEntry = currentMeasurementSequence[currentMeasurementSequence.length - 1];
                  if (!lastEntry.segments) lastEntry.segments = [];
                  lastEntry.segments.push({ line: line, label: label });
              }
         });
    }

    function finishMeasurement(closed) {
        // ... (keep as is) ...
         if (measurementState !== 'measuring' || currentMeasurementSequence.length < (closed ? 3 : 2)) {
             resetMeasurementState(); return;
         }
         const color = measurementColors[measurementColorIndex];
         let totalLength = 0;
         for (let i = 0; i < currentMeasurementSequence.length; i++) {
             const entry = currentMeasurementSequence[i];
             if (entry.segments) {
                 entry.segments.forEach(segData => {
                     const dist = parseFloat(segData.label.userData.text);
                     if (!isNaN(dist)) totalLength += dist;
                 });
             }
         }
         if (closed) {
             const points2D = projectPointsToPlane(currentMeasurementSequence.map(p => p.point));
             const area = calculatePolygonArea(points2D) * (scaleFactor * scaleFactor);
             if (area > 1e-6) {
                 const areaLabel = createDistanceLabel(`Area: ${area.toFixed(2)}`, color, 14);
                 const centroid = new THREE.Vector3();
                 currentMeasurementSequence.forEach(p => centroid.add(p.point));
                 centroid.divideScalar(currentMeasurementSequence.length);
                 areaLabel.position.copy(centroid);
                 areaLabel.userData.isAreaLabel = true;
                 areaLabel.userData.colorIndex = measurementColorIndex;
                 measurementGroup.add(areaLabel);
                 currentMeasurementSequence[0].areaLabel = areaLabel;
             }
              console.log(`Finished measurement (Closed Area): ${area.toFixed(2)}, Total Length: ${totalLength.toFixed(2)}`);
         } else {
              console.log(`Finished measurement (Open Path): Total Length: ${totalLength.toFixed(2)}`);
         }
         resetMeasurementState();
    }

    function resetMeasurementState() {
        // ... (keep as is) ...
        measurementState = 'idle';
        currentMeasurementSequence = [];
        currentAxisSnap = null;
        if (previewLine) {
            measurementGroup.remove(previewLine);
            if (previewLine.geometry) previewLine.geometry.dispose();
            if (previewLine.material) previewLine.material.dispose();
            previewLine = null;
        }
        console.log("Measurement state reset to idle.");
    }

    function removeLastMeasurementSegment() {
        // ... (keep as is) ...
        if (measurementState !== 'measuring' || currentMeasurementSequence.length <= 1) {
             if (currentMeasurementSequence.length === 1) resetMeasurementState();
             return;
        }
        let entryToRemoveSegmentsFrom = null;
        for (let i = currentMeasurementSequence.length - 1; i >= 0; i--) {
            if (currentMeasurementSequence[i].segments && currentMeasurementSequence[i].segments.length > 0) {
                entryToRemoveSegmentsFrom = currentMeasurementSequence[i];
                break;
            }
        }
        if (!entryToRemoveSegmentsFrom) {
             currentMeasurementSequence.pop(); updatePreviewLine(); return;
        }
        const lastSegmentData = entryToRemoveSegmentsFrom.segments.pop();
        if (lastSegmentData) {
            measurementGroup.remove(lastSegmentData.line);
            measurementGroup.remove(lastSegmentData.label);
            lastSegmentData.line.geometry.dispose();
            lastSegmentData.line.material.dispose();
            disposeLabel(lastSegmentData.label);
        }
        const startIndexToRemove = currentMeasurementSequence.indexOf(entryToRemoveSegmentsFrom);
        if (startIndexToRemove < currentMeasurementSequence.length -1) {
             currentMeasurementSequence.splice(startIndexToRemove + 1);
        }
        console.log("Removed last measurement segment/point(s).");
        updatePreviewLine();
    }

    function updatePreviewLine(targetPoint = null) {
        // ... (keep as is) ...
         if (!targetPoint || measurementState !== 'measuring' || currentMeasurementSequence.length === 0) {
             if (previewLine) previewLine.visible = false;
             return;
         }
         const lastPoint = currentMeasurementSequence[currentMeasurementSequence.length - 1].point;
         const color = measurementColors[measurementColorIndex];
         let previewEndPoint = targetPoint.clone();
         if (currentAxisSnap) {
              const delta = previewEndPoint.clone().sub(lastPoint);
              previewEndPoint = lastPoint.clone();
              if (currentAxisSnap === 'x') previewEndPoint.x += delta.x;
              else if (currentAxisSnap === 'y') previewEndPoint.y += delta.y;
              else if (currentAxisSnap === 'z') previewEndPoint.z += delta.z;
         }
         if (!previewLine) {
             const geometry = new THREE.BufferGeometry().setFromPoints([lastPoint, previewEndPoint]);
             const material = new THREE.LineDashedMaterial({ color: color, linewidth: 1, scale: 1, dashSize: 0.1, gapSize: 0.05 });
             previewLine = new THREE.Line(geometry, material);
             previewLine.computeLineDistances();
             measurementGroup.add(previewLine);
         } else {
             previewLine.geometry.setFromPoints([lastPoint, previewEndPoint]);
             previewLine.geometry.attributes.position.needsUpdate = true;
             previewLine.computeLineDistances();
             previewLine.material.color.setHex(color);
             previewLine.visible = true;
         }
    }

    // --- Helper Functions ---
    function createDistanceLabel(text, colorHex, fontSize = 12) {
        // ... (keep as is) ...
         const canvas = document.createElement('canvas');
         const context = canvas.getContext('2d');
         context.font = `Bold ${fontSize}px Arial`;
         const textMetrics = context.measureText(text);
         const textWidth = textMetrics.width;
         const padding = 8;
         canvas.width = textWidth + padding * 2;
         canvas.height = fontSize + padding * 2;
         context.font = `Bold ${fontSize}px Arial`;
         context.textAlign = 'center';
         context.textBaseline = 'middle';
         context.fillStyle = `#${colorHex.toString(16).padStart(6, '0')}`;
         context.globalAlpha = 0.7;
         context.fillRect(0, 0, canvas.width, canvas.height);
         context.globalAlpha = 1.0;
         context.fillStyle = '#ffffff';
         context.fillText(text, canvas.width / 2, canvas.height / 2);
         const texture = new THREE.CanvasTexture(canvas);
         texture.needsUpdate = true;
         const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false });
         const sprite = new THREE.Sprite(material);
         const aspect = canvas.width / canvas.height;
         sprite.scale.set(0.05 * aspect, 0.05, 1);
         sprite.renderOrder = 1;
         sprite.userData.text = text;
         return sprite;
    }

    function disposeLabel(labelSprite) {
        // ... (keep as is) ...
        if (labelSprite && labelSprite.material) {
            if (labelSprite.material.map) labelSprite.material.map.dispose();
            labelSprite.material.dispose();
        }
    }

    function projectPointsToPlane(points) {
        // ... (keep as is) ...
        if (points.length < 3) return [];
        const v1 = new THREE.Vector3().subVectors(points[1], points[0]);
        const v2 = new THREE.Vector3().subVectors(points[2], points[0]);
        const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
        if (normal.lengthSq() < 0.1) return points.map(p => new THREE.Vector2(p.x, p.y));
        const absX = Math.abs(normal.x), absY = Math.abs(normal.y), absZ = Math.abs(normal.z);
        let projectedPoints;
        if (absZ >= absX && absZ >= absY) projectedPoints = points.map(p => new THREE.Vector2(p.x, p.y));
        else if (absY >= absX && absY >= absZ) projectedPoints = points.map(p => new THREE.Vector2(p.x, p.z));
        else projectedPoints = points.map(p => new THREE.Vector2(p.y, p.z));
        return projectedPoints;
    }

    function calculatePolygonArea(points2D) {
        // ... (keep as is) ...
        let area = 0;
        for (let i = 0; i < points2D.length; i++) {
            const j = (i + 1) % points2D.length;
            area += points2D[i].x * points2D[j].y;
            area -= points2D[j].x * points2D[i].y;
        }
        return Math.abs(area / 2);
    }

    function setReferenceScale(clickedLabel) {
        // ... (keep as is) ...
         const currentText = clickedLabel.userData.text;
         const currentValue = parseFloat(currentText);
         if (isNaN(currentValue) || !clickedLabel.userData.segmentStart || !clickedLabel.userData.segmentEnd) return;
         const newScaleInput = prompt(`Set reference distance for this segment (current: ${currentValue.toFixed(2)}):`, currentValue.toFixed(2));
         if (newScaleInput === null) return;
         const newReferenceValue = parseFloat(newScaleInput);
         if (isNaN(newReferenceValue) || newReferenceValue <= 0) { alert("Invalid distance."); return; }
         const originalDistance = clickedLabel.userData.segmentStart.distanceTo(clickedLabel.userData.segmentEnd);
         if (originalDistance < 1e-6) { alert("Cannot scale zero-length segment."); return; }
         scaleFactor = newReferenceValue / originalDistance;
         console.log(`New scale factor set: ${scaleFactor}`);
         updateAllMeasurementLabels();
    }

    function updateAllMeasurementLabels() {
        // ... (keep as is) ...
        measurementGroup.children.forEach(child => {
            if (child.userData.isDistanceLabel && child.userData.segmentStart && child.userData.segmentEnd) {
                const originalDistance = child.userData.segmentStart.distanceTo(child.userData.segmentEnd);
                const scaledDistance = originalDistance * scaleFactor;
                const newText = scaledDistance.toFixed(2);
                const colorIndex = child.userData.colorIndex ?? 0;
                const newLabel = createDistanceLabel(newText, measurementColors[colorIndex]);
                newLabel.position.copy(child.position);
                newLabel.userData = { ...child.userData, text: newText };
                measurementGroup.remove(child);
                disposeLabel(child);
                measurementGroup.add(newLabel);
            } else if (child.userData.isAreaLabel) {
                 console.warn("Area label update after scaling not fully implemented.");
            }
        });
    }

    function clearReferencePoints() {
         if (confirm("Are you sure you want to clear ALL reference points? This cannot be undone.")) {
             while (markerGroup.children.length > 0) {
                 markerGroup.remove(markerGroup.children[0]);
             }
             console.log("All reference points cleared.");
             // Also clear measurements that depend on these points
             clearMeasurements(false); // Clear without asking again
             deactivateTransformMode(); // Ensure gizmo is off
         }
    }

    function clearMeasurements(askConfirmation = true) {
         let confirmed = !askConfirmation;
         if (askConfirmation) {
             confirmed = confirm("Are you sure you want to clear ALL measurements? This cannot be undone.");
         }
        if (confirmed) {
            const toRemove = [];
            measurementGroup.children.forEach(child => {
                 if (child.userData.isMeasurementLine || child.userData.isDistanceLabel || child.userData.isAreaLabel || child === previewLine) {
                     toRemove.push(child);
                 }
            });
            toRemove.forEach(child => {
                measurementGroup.remove(child);
                if (child.isLine) { child.geometry.dispose(); child.material.dispose(); }
                else if (child.isSprite) { disposeLabel(child); }
            });
            resetMeasurementState();
            console.log("All measurements cleared.");
            deactivateTransformMode(); // Ensure gizmo is off
        }
    }

  </script>
</body>
</html>