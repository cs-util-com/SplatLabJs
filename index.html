<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>3D Gaussian Splat Viewer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
        background-color: #000; /* Default background for Three.js */
        overflow: hidden; /* Prevent scrollbars */
    }
    #renderer-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0; /* Behind the UI panel */
        cursor: crosshair; /* Indicate interaction possibility */
    }
    #container {
        position: absolute; /* Changed from relative */
        top: 10px; /* Position from top */
        left: 10px; /* Position from left */
        z-index: 1; /* Above the renderer */
        pointer-events: none; /* Allow clicks to pass through container */
    }
    #view-panel {
        pointer-events: auto; /* Re-enable pointer events for the panel itself */
        background-color: rgba(243, 244, 246, 0.9); /* bg-gray-100 with opacity */
        display: inline-block; /* Make panel fit content */
    }
    /* Minimal styles for loading icon if needed before Tailwind loads or for custom animations */
    .loading-icon {
        width: 35px;
        margin: 10px auto;
        background: #324d70; /* Tailwind bg-blue-800 */
        aspect-ratio: 1;
        border-radius: 50%;
        --_m:
            conic-gradient(#0000,#000),
            linear-gradient(#000 0 0) content-box;
        -webkit-mask: var(--_m);
            mask: var(--_m);
        -webkit-mask-composite: source-out;
            mask-composite: subtract;
        box-sizing: border-box;
        animation: ply-load 1s linear infinite;
    }

    @keyframes ply-load {
        to{transform: rotate(1turn)}
    }
    .file-ext, .file-ext-small {
        border: 1px solid #bababa; /* Tailwind border-gray-300 */
        border-radius: 3px; /* Tailwind rounded-sm */
        background-color: #e6e6e6; /* Tailwind bg-gray-200 */
        padding: 1px 4px;
        margin: 0 2px;
        font-size: 0.875rem; /* Tailwind text-sm */
        display: inline-block;
    }
    .file-ext-small {
         background-color: #dfdfdf; /* Tailwind bg-gray-100 */
         padding-bottom: 1px;
    }
    .measurement-label {
        color: white;
        padding: 2px 5px;
        border-radius: 3px;
        font-size: 10px; /* Smaller font for labels */
        font-family: sans-serif;
        text-shadow: 1px 1px 2px black; /* Improve readability */
    }
  </style>
  <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.174.0/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.174.0/examples/jsm/",
            "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.4/spark.module.js"
        }
    }
  </script>
</head>

<body class="h-screen m-0 font-sans text-base">
  <!-- UI Panel -->
  <div id="container"> <!-- Removed flex classes -->
    <div id ="view-panel" class="p-3 text-gray-900 rounded-lg border border-gray-300 w-auto text-center shadow-lg"> <!-- Adjusted padding, width, text-align -->
        <div class="flex flex-col space-y-2"> <!-- Use flex column for layout -->
            <label for="viewFile" class="inline-block" title="Load .ply, .splat, .spz">
                <span class="text-blue-800 border border-blue-300 bg-blue-100 hover:bg-blue-200 hover:border-blue-500 hover:text-blue-900 py-1 px-3 rounded-md shadow-md cursor-pointer mx-auto block w-full">Add .ply, .splat, .spz</span>
                <input type="file" id="viewFile" class="hidden" onchange="window.onFileChange(this)" accept=".ply,.splat,.spz"> <!-- Updated file extensions for new library -->
            </label>
            <div class="flex items-center justify-center space-x-3"> <!-- Flex row for inputs -->
                 <div class="flex items-center space-x-1">
                     <label for="alphaRemovalThresholdView" class="text-sm text-gray-600">Alpha (1-255):</label>
                     <input id="alphaRemovalThresholdView" type="text" class="border border-gray-400 bg-white p-1 rounded-md w-12 text-sm" value="1" placeholder="1-255">
                 </div>
                 <div class="flex items-center space-x-1">
                     <label for="viewSphericalHarmonicsDegree" class="text-sm text-gray-600">SH:</label>
                     <!-- Replace input with select -->
                     <select id="viewSphericalHarmonicsDegree" class="border border-gray-400 bg-white p-1 rounded-md text-sm appearance-none focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="padding-right: 1.5rem; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%2020%2020%22%20fill%3D%22currentColor%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20d%3D%22M5.293%207.293a1%201%200%20011.414%200L10%2010.586l3.293-3.293a1%201%200%20111.414%201.414l-4%204a1%201%200%2001-1.414%200l-4-4a1%201%200%20010-1.414z%22%20clip-rule%3D%22evenodd%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1em 1em;">
                         <option value="0" selected>0</option>
                         <option value="1">1</option>
                         <option value="2">2</option>
                     </select>
                 </div>
            </div>
            <!-- Add Rotation Checkbox -->
            <div class="flex items-center justify-center space-x-1 mt-1">
                <input type="checkbox" id="rotateSplatCheckbox" class="form-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                <label for="rotateSplatCheckbox" class="ml-2 text-sm text-gray-600">Rotate 180Â° (X-axis)</label>
            </div>
            <!-- Add Camera FOV Control -->
            <div class="flex items-center justify-center space-x-1 mt-1 border-t pt-2 border-gray-300">
                <label for="fovSlider" class="text-sm text-gray-600 whitespace-nowrap">FOV:</label>
                <input type="range" id="fovSlider" min="1" max="120" value="75" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 mx-2">
                <span id="fovValue" class="text-sm text-gray-600 w-8 text-right">75</span>
            </div>
            <!-- Add Background Color Control -->
            <div class="flex items-center justify-center space-x-1 mt-1">
                <label for="bgColorPicker" class="text-sm text-gray-600 whitespace-nowrap">BG:</label>
                <input type="color" id="bgColorPicker" value="#000000" class="h-6 w-full border border-gray-400 rounded cursor-pointer mx-2">
            </div>
            <!-- Action Controls -->
            <div class="border-t pt-2 mt-2 border-gray-300 flex justify-center space-x-2">
                 <button id="clearPointsButton" class="text-xs bg-red-100 hover:bg-red-200 text-red-800 border border-red-300 hover:border-red-500 py-1 px-2 rounded shadow-sm">Clear Points</button>
                 <button id="clearMeasurementsButton" class="text-xs bg-yellow-100 hover:bg-yellow-200 text-yellow-800 border border-yellow-300 hover:border-yellow-500 py-1 px-2 rounded shadow-sm">Clear Measures</button>
                 <button id="clearAllButton" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-800 border border-gray-400 py-1 px-2 rounded shadow-sm">Clear All</button>
            </div>
            <!-- Transform Mode Toggle Button -->
            <div class="border-t pt-2 mt-2 border-gray-300 flex justify-center">
                 <button id="toggleTransformModeButton" class="text-sm bg-gray-200 hover:bg-gray-300 text-gray-800 border border-gray-400 hover:border-gray-500 py-1 px-3 rounded shadow-sm w-full">Enable Transform</button>
            </div>
            <!-- Transform Mode Options (Initially Hidden) -->
            <div id="transformModeOptions" class="hidden mt-2 flex justify-center space-x-1">
                 <button id="setTranslateMode" title="Translate (W)" class="text-xs bg-blue-100 hover:bg-blue-200 text-blue-800 border border-blue-300 hover:border-blue-500 py-1 px-2 rounded shadow-sm">Move (W) </button>
                 <button id="setRotateMode" title="Rotate (E)" class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 border border-gray-300 hover:border-gray-500 py-1 px-2 rounded shadow-sm">Rotate (E) </button>
                 <button id="setScaleMode" title="Scale (R)" class="text-xs bg-gray-100 hover:bg-gray-200 text-gray-800 border border-gray-300 hover:border-gray-500 py-1 px-2 rounded shadow-sm">Scale (R) </button>
            </div>
        </div>
    </div>
  </div>

  <!-- Three.js Renderer Container -->
  <div id="renderer-container"></div>
  <script src="lib/support-bubble.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { SplatMesh } from '@sparkjsdev/spark';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { DragControls } from 'three/addons/controls/DragControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js'; // Import TransformControls

    let scene, camera, renderer, controls;
    const splatMeshes = []; // An array to hold all splat meshes
    // Add references for FOV controls
    let fovSlider, fovValueDisplay;
    // Add reference for background color picker
    let bgColorPicker;
    // Add variables for DragControls and drag state
    let dragControls;
    let draggedObject = null;
    let dragAxis = null;
    let initialPosition = new THREE.Vector3();
    const dragPlane = new THREE.Plane();
    const dragRaycaster = new THREE.Raycaster();
    const dragIntersection = new THREE.Vector3();
    const dragOffset = new THREE.Vector3(); // To store initial offset on the plane
    // Declare markerGroup here so it's accessible within initThree scope before DragControls
    let markerGroup; 
    // Add variable to store current mouse NDC
    const currentMouseNDC = new THREE.Vector2();
    let transformControls; // Declare TransformControls variable
    let transformModeActive = false; // State for transform mode
    let toggleTransformModeButton; // Reference to the button
    // Add references for transform mode options
    let transformModeOptionsContainer;
    let setTranslateModeButton, setRotateModeButton, setScaleModeButton;

    // --- Variables for Right Mouse Drag Detection ---
    let isRightMouseButtonDown = false;
    let rightMouseDragHappened = false;
    const rightMouseDragThreshold = 5; // pixels for drag detection
    let rightMouseDownPosition = { x: 0, y: 0 };
    
    // --- Raycaster Setup ---
    const outHits = [];
    const renderDimensions = new THREE.Vector2();
    const clickRaycaster = new THREE.Raycaster(); // Use a separate raycaster for clicks to avoid conflicts
    clickRaycaster.params.Line = clickRaycaster.params.Line || {}; // Ensure params.Line exists
    clickRaycaster.params.Line.threshold = 0.1; // Adjust threshold for clicking lines
    clickRaycaster.params.Points = clickRaycaster.params.Points || {}; // Ensure params.Points exists
    clickRaycaster.params.Points.threshold = 0.1; // If needed for points
    // Initialize raycaster for drag operations

    // --- Measurement Variables ---
    let measurementState = 'idle'; // 'idle', 'measuring'
    let currentMeasurementSequence = []; // { point: THREE.Vector3, marker: THREE.Group, segmentLine?: THREE.Line, distanceLabel?: THREE.Sprite, areaLabel?: THREE.Sprite }
    let measurementGroup; // Group for lines and labels
    let previewLine = null;
    let measurementColors = [0xff00ff, 0x00ffff, 0xffff00, 0xffa500, 0x00ff7f, 0xadd8e6]; // Magenta, Cyan, Yellow, Orange, SpringGreen, LightBlue
    let measurementColorIndex = 0;
    let scaleFactor = 1.0; // 1 unit in Three.js = 1 unit in real world initially
    let currentAxisSnap = null; // null, 'x', 'y', 'z'

    // --- Helper Function to Detach Gizmo ---
    function detachGizmo() {
        if (transformControls.object) {
            transformControls.detach();
            transformControls.visible = false;
            transformControls.enabled = false;
            console.log("Gizmo detached.");
        }
    }

    // --- Helper Function to Update Transform Button State ---
    function updateTransformButtonState() {
        if (transformModeActive) {
            toggleTransformModeButton.textContent = "Disable Transform";
            toggleTransformModeButton.classList.remove('bg-gray-200', 'hover:bg-gray-300', 'text-gray-800', 'border-gray-400', 'hover:border-gray-500');
            toggleTransformModeButton.classList.add('bg-green-200', 'hover:bg-green-300', 'text-green-900', 'border-green-400', 'hover:border-green-600');
        } else {
            toggleTransformModeButton.textContent = "Enable Transform";
            toggleTransformModeButton.classList.remove('bg-green-200', 'hover:bg-green-300', 'text-green-900', 'border-green-400', 'hover:border-green-600');
            toggleTransformModeButton.classList.add('bg-gray-200', 'hover:bg-gray-300', 'text-gray-800', 'border-gray-400', 'hover:border-gray-500');
        }
    }

    // --- Helper Function to Update Transform Mode Buttons Visual State ---
    function updateTransformModeButtons(activeMode) {
        const buttons = [setTranslateModeButton, setRotateModeButton, setScaleModeButton];
        const modes = ['translate', 'rotate', 'scale'];
        const activeClasses = ['bg-blue-200', 'border-blue-500', 'text-blue-900'];
        const inactiveClasses = ['bg-gray-100', 'hover:bg-gray-200', 'text-gray-800', 'border-gray-300', 'hover:border-gray-500'];

        buttons.forEach((button, index) => {
            // Remove all potentially conflicting classes first
            button.classList.remove(...activeClasses, ...inactiveClasses);

            if (modes[index] === activeMode) {
                button.classList.add(...activeClasses);
            } else {
                button.classList.add(...inactiveClasses);
            }
        });
    }


    // --- Helper Function to Deactivate Transform Mode ---
    function deactivateTransformMode() {
        if (transformModeActive) {
            transformModeActive = false;
            detachGizmo();
            updateTransformButtonState();
            transformModeOptionsContainer.classList.add('hidden'); // Hide mode options
            console.log("Transform mode deactivated.");
        }
    }


    function initThree() {
        const container = document.getElementById('renderer-container');

        // Scene
        scene = new THREE.Scene();
        // Set initial background color
        scene.background = new THREE.Color(0x000000); // Black

        // Camera
        const initialFov = 75; // Store initial FOV
        camera = new THREE.PerspectiveCamera(initialFov, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5); // Default position

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Add pointermove listener to track mouse position AND detect right-drag
        renderer.domElement.addEventListener('pointermove', onPointerMove, false); // Listener for onPointerMove

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false; // Optional damping effect
        controls.target.set(0, 0, 0); // Set initial lookAt
        controls.update();

        // Axes Helper
        const axesHelper = new THREE.AxesHelper( 5 ); // Length of 5 units
        scene.add(axesHelper);

        // Grid Helper
        const size = 10; // Size of the grid (e.g., 10x10 units)
        const divisions = 10; // Number of divisions within the grid
        const gridHelper = new THREE.GridHelper( size, divisions );
        scene.add(gridHelper);

        // SplatMesh will be created when a file is loaded - no initialization needed here

        // --- Marker Group Initialization (Moved Earlier) ---
        // Create a group to hold all marker spheres
        markerGroup = new THREE.Group(); // Assign to the outer scope variable
        scene.add(markerGroup);

        // --- Measurement Group Initialization ---
        measurementGroup = new THREE.Group();
        scene.add(measurementGroup);

        // --- Transform Controls Initialization ---
        transformControls = new TransformControls(camera, renderer.domElement);
        transformControls.addEventListener('dragging-changed', function (event) {
            controls.enabled = !event.value; // Disable OrbitControls while dragging gizmo
        });
        transformControls.visible = false; // Initially hidden
        transformControls.enabled = false; // Initially disabled
        // scene.add(transformControls); // BUG FIX: DO NOT add transformControls to the scene directly.

        // Get FOV UI elements
        fovSlider = document.getElementById('fovSlider');
        fovValueDisplay = document.getElementById('fovValue');
        // Get Background Color Picker element
        bgColorPicker = document.getElementById('bgColorPicker');

        // Set initial FOV display
        fovValueDisplay.textContent = initialFov;
        fovSlider.value = initialFov;

        // Add FOV slider event listener
        fovSlider.addEventListener('input', () => {
            const newFov = parseInt(fovSlider.value);

            // Calculate distance adjustment to maintain apparent size at target
            const currentDistance = camera.position.distanceTo(controls.target);
            const currentFovRad = THREE.MathUtils.degToRad(camera.fov);
            const newFovRad = THREE.MathUtils.degToRad(newFov);

            // Avoid division by zero/very small numbers if tan(newFovRad / 2) is close to zero
            const tanNewFovHalf = Math.tan(newFovRad / 2);
            if (tanNewFovHalf > 1e-6) { // Check against a small epsilon
                const newDistance = currentDistance * (Math.tan(currentFovRad / 2) / tanNewFovHalf);

                // Calculate direction and new position
                const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
                const newPosition = new THREE.Vector3().copy(controls.target).addScaledVector(direction, newDistance);

                // Update camera position first
                camera.position.copy(newPosition);
            } else {
                 console.warn("FOV too small, cannot adjust distance effectively.");
            }


            // Update camera FOV
            camera.fov = newFov;
            camera.updateProjectionMatrix();
            fovValueDisplay.textContent = newFov;
        });

        // Add Background Color Picker event listener
        bgColorPicker.addEventListener('input', (event) => {
            const newColor = event.target.value;
            scene.background = new THREE.Color(newColor);
        });

        // Get Transform Mode Button element
        toggleTransformModeButton = document.getElementById('toggleTransformModeButton');
        // Get Transform Mode Options elements
        transformModeOptionsContainer = document.getElementById('transformModeOptions');
        setTranslateModeButton = document.getElementById('setTranslateMode');
        setRotateModeButton = document.getElementById('setRotateMode');
        setScaleModeButton = document.getElementById('setScaleMode');


        // Add Transform Mode Button event listener
        toggleTransformModeButton.addEventListener('click', () => {
            transformModeActive = !transformModeActive; // Toggle the state
            updateTransformButtonState(); // Update button appearance
            if (!transformModeActive) {
                detachGizmo(); // Detach gizmo if disabling the mode
                transformModeOptionsContainer.classList.add('hidden'); // Hide mode options
                console.log("Transform mode disabled via button.");
            } else {
                transformModeOptionsContainer.classList.remove('hidden'); // Show mode options
                updateTransformModeButtons(transformControls.mode); // Update button styles to current mode
                console.log("Transform mode enabled via button. Click splat to activate gizmo.");
                 // If measuring, cancel it when enabling transform mode
                 if (measurementState === 'measuring') {
                     console.log("Transform mode enabled while measuring. Cancelling measurement.");
                     resetMeasurementState();
                 }
            }
        });

        // Add listeners for mode change buttons
        setTranslateModeButton.addEventListener('click', () => {
            if (transformModeActive && transformControls.object) {
                transformControls.setMode('translate');
                updateTransformModeButtons('translate');
            }
        });
        setRotateModeButton.addEventListener('click', () => {
            if (transformModeActive && transformControls.object) {
                transformControls.setMode('rotate');
                updateTransformModeButtons('rotate');
            }
        });
        setScaleModeButton.addEventListener('click', () => {
            if (transformModeActive && transformControls.object) {
                transformControls.setMode('scale');
                updateTransformModeButtons('scale');
            }
        });


        // Initialize DragControls after markerGroup is added to the scene
        // Pass markerGroup.children, camera, and renderer.domElement
        // Note: DragControls modifies the passed array, so using markerGroup.children directly works.
        dragControls = new DragControls(markerGroup.children, camera, renderer.domElement);
        dragControls.enabled = true; // Ensure it's enabled

        // --- DragControls Event Listeners ---

        dragControls.addEventListener('dragstart', function (event) {
            const object = event.object; // This is the clicked mesh (crossMeshX, Y, or Z)
            if (!object.parent || !object.parent.isGroup) return; // Ensure it's part of a cross marker

            console.log("Drag Start:", object.name);
            controls.enabled = false; // Disable OrbitControls during drag
            draggedObject = object.parent; // Store the parent group (the whole cross)
            initialPosition.copy(draggedObject.position); // Store initial position

            // Determine the axis based on the clicked mesh's name
            switch (object.name) {
                case 'crossX':
                    dragAxis = new THREE.Vector3(1, 0, 0); // Local X
                    break;
                case 'crossY':
                    dragAxis = new THREE.Vector3(0, 1, 0); // Local Y
                    break;
                case 'crossZ':
                    dragAxis = new THREE.Vector3(0, 0, 1); // Local Z
                    break;
                default:
                    dragAxis = null;
                    draggedObject = null;
                    controls.enabled = true; // Re-enable if not a valid part
                    return;
            }

            // Create a plane perpendicular to the camera view, passing through the object's center
            const cameraDirection = camera.getWorldDirection(new THREE.Vector3());
            dragPlane.setFromNormalAndCoplanarPoint(cameraDirection, initialPosition);

            // Raycast to find the initial intersection point on the plane
            if (event.domEvent) { // Check if there's a valid DOM event with clientX and clientY
                const mouse = new THREE.Vector2(
                    (event.domEvent.clientX / window.innerWidth) * 2 - 1,
                    -(event.domEvent.clientY / window.innerHeight) * 2 + 1
                );
                dragRaycaster.setFromCamera(mouse, camera);
                if (dragRaycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                    // This is the key change - we calculate dragOffset as the vector from
                    // the intersection point to the object's center
                    dragOffset.subVectors(initialPosition, dragIntersection);
                    console.log("Initial plane intersection:", dragIntersection);
                } else {
                    console.warn("Could not intersect drag plane on dragstart.");
                    dragOffset.set(0,0,0);
                }
            } else {
                // Fallback if no valid dom event
                dragRaycaster.setFromCamera(currentMouseNDC, camera);
                if (dragRaycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                    dragOffset.subVectors(initialPosition, dragIntersection);
                } else {
                    console.warn("Could not intersect drag plane on dragstart using NDC.");
                    dragOffset.set(0,0,0);
                }
            }
            
            // Reset the child object's position to prevent its own movement
            event.object.position.set(0, 0, 0);
        });

        dragControls.addEventListener('drag', function (event) {
            if (!draggedObject || !dragAxis) return;

            // Raycast from current mouse position (using tracked NDC) to the drag plane
            dragRaycaster.setFromCamera(currentMouseNDC, camera); // Use tracked mouse position

            if (dragRaycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                // Add the stored offset to get the new position
                // This preserves the original click offset from the center
                const targetPointOnPlane = dragIntersection.clone().add(dragOffset);
                
                // Calculate the displacement vector on the plane
                const displacementOnPlane = targetPointOnPlane.clone().sub(initialPosition);

                // Get the world-space direction of the selected local axis
                const worldAxis = dragAxis.clone().applyQuaternion(draggedObject.quaternion).normalize();

                // Project the displacement vector onto the world axis
                const projectedDisplacement = worldAxis.clone().multiplyScalar(displacementOnPlane.dot(worldAxis));

                // Update the parent object's position
                draggedObject.position.copy(initialPosition).add(projectedDisplacement);

                // Reset the position of the actually dragged child mesh relative to its parent
                event.object.position.set(0, 0, 0); 
            }
        });

        dragControls.addEventListener('dragend', function (event) {
            console.log("Drag End");
            if (draggedObject) { // Only re-enable if a drag actually happened
                 controls.enabled = true;
            }
            // Clear state
            draggedObject = null;
            dragAxis = null;
            initialPosition.set(0,0,0);
            dragOffset.set(0,0,0);
        });

        // Prevent DragControls from activating on non-left mouse buttons
        renderer.domElement.addEventListener('pointerdown', function(event) {
            // Right mouse button drag detection setup
            if (event.button === 2) { // Right mouse button
                isRightMouseButtonDown = true;
                rightMouseDragHappened = false; // Reset drag flag on new mousedown
                rightMouseDownPosition.x = event.clientX;
                rightMouseDownPosition.y = event.clientY;
            }

            // Original DragControls logic for non-left mouse buttons
            if (event.button !== 0) { // 0 = left, 1 = middle, 2 = right
                // If it's not the left button, and dragControls is currently enabled,
                // disable it to prevent dragging with this button press.
                if (dragControls && dragControls.enabled) {
                    dragControls.enabled = false;
                    renderer.domElement._wasDragControlsDisabledForNonLeftClick = true;
                }
            } else {
                // It is the left button.
                // If dragControls was disabled by our logic (e.g., a non-left button was pressed and held, then left was pressed),
                // we should ensure it's enabled for this left click.
                if (dragControls && !dragControls.enabled && renderer.domElement._wasDragControlsDisabledForNonLeftClick) {
                     dragControls.enabled = true;
                     // The flag will be cleared on the eventual pointerup for the non-left button.
                }
            }
        }, true); // Use capture phase

        renderer.domElement.addEventListener('pointerup', function(event) {
            // Right mouse button state update
            if (event.button === 2) { // Right mouse button
                isRightMouseButtonDown = false;
                // rightMouseDragHappened is now set correctly by onPointerMove if a drag occurred.
                // It will be used by onRightClick (contextmenu event) and reset on the next right mousedown.
            }

            // If dragControls was disabled by our pointerdown listener for a non-left click,
            // re-enable it now that the button is up.
            if (renderer.domElement._wasDragControlsDisabledForNonLeftClick) {
                if (dragControls) { // Check if dragControls exists
                    dragControls.enabled = true;
                }
                renderer.domElement._wasDragControlsDisabledForNonLeftClick = false;
            }
        }, true); // Use capture phase

        // --- UI and Measurement Event Listeners ---
        renderer.domElement.addEventListener('click', onClick, false); // Use click for measurement AND gizmo activation
        renderer.domElement.addEventListener('contextmenu', onRightClick, false); // Added for right-click to delete measurement
        window.addEventListener('keydown', onKeyDown, false);
        document.getElementById('clearPointsButton').addEventListener('click', () => clearReferencePoints(true));
        document.getElementById('clearMeasurementsButton').addEventListener('click', () => clearMeasurements(true));
        document.getElementById('clearAllButton').addEventListener('click', clearAll);


        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);

        // Start animation loop
        animate();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update(); // Update controls
        renderer.render(scene, camera);
    }

    // Initialize Three.js setup on load
    initThree();

    // --- Splat Loading Logic ---

    // Supported file extensions for @sparkjsdev/spark
    const supportedExtensions = ['.ply', '.splat', '.spz']; // Note: .ksplat is no longer supported
    
    // Helper function to check if file is supported
    function getFileExtension(filename) {
      const lastDotIndex = filename.lastIndexOf('.');
      return lastDotIndex !== -1 ? filename.slice(lastDotIndex).toLowerCase() : '';
    }
    
    // Assign functions to window object to make them accessible from inline HTML event handlers
    window.onFileChange = function(arg) { // Assign directly to window.onFileChange
      const viewFile = document.getElementById("viewFile");

      if (!arg || !arg.files || arg.files.length === 0) {
          return;
      }

      const alphaRemovalThreshold = parseInt(document.getElementById("alphaRemovalThresholdView").value);
      // Read sphericalHarmonicsDegree input reading from select element
      const sphericalHarmonicsDegree = parseInt(document.getElementById("viewSphericalHarmonicsDegree").value);
      // Read rotation checkbox state
      const rotateSplat = document.getElementById("rotateSplatCheckbox").checked;

      // Validation
      if (isNaN(alphaRemovalThreshold) || alphaRemovalThreshold < 0 || alphaRemovalThreshold > 255) {
        console.error("Invalid alpha removal threshold (0-255).");
        return;
      }

      const viewFileName = viewFile.files[0].name.trim();
      const fileExtension = getFileExtension(viewFileName);
      
      if (!supportedExtensions.includes(fileExtension)) {
          console.error(`Unsupported file format: ${fileExtension}. Please use one of: ${supportedExtensions.join(', ')}`);
          return;
      }

      try {
        // Create a URL for the file to load with SplatMesh
        const fileURL = URL.createObjectURL(viewFile.files[0]);
        console.log(`Loading splat from URL: ${fileURL}`);
        
        try {
          // Create a new SplatMesh instance - this matches the Spark example approach
          const newSplatMesh = new SplatMesh({
            url: fileURL,
            alphaThreshold: alphaRemovalThreshold / 255
          });
                   
          // Apply rotation if needed 
          if (rotateSplat) {
            console.log("Applying 180-degree X rotation to splat mesh...");
            newSplatMesh.rotation.x += Math.PI; // Rotate 180 degrees around X-axis
            console.log("Rotation applied to mesh.");
          }
          
          // Add the new splat mesh to the scene and our array
          scene.add(newSplatMesh);
          splatMeshes.push(newSplatMesh);
          
          console.log("SplatMesh created and added to scene");

          // IMPROVEMENT: Add an event listener to the new mesh. Once it's ready, we can revoke the URL.
          // This is more robust than a fixed timeout.
          newSplatMesh.addEventListener('ready', () => {
              console.log(`Splat mesh from ${fileURL} is ready. Revoking object URL.`);
              URL.revokeObjectURL(fileURL);
          });

        } catch (error) {
          console.error("Error creating SplatMesh:", error);
        }
        
        // Detach gizmo and deactivate mode after loading new splat data
        deactivateTransformMode(); // Use helper function
        
      } catch (e) {
        console.error("Could not load scene: " + e.message);
      }
    }

    // --- Click-to-Spawn Reference Point Feature (Modified for dblclick) ---
    // --- Define materials and geometry for the cross marker ---
    const baseCrossSize = 0.2; // Base size of the cross arms at reference distance
    const crossThicknessRatio = 0.1; // Thickness relative to size
    // Geometry will be created dynamically based on scale

    const crossMaterialX = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red for X
    const crossMaterialY = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Green for Y
    const crossMaterialZ = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Blue for Z

    // Function to create a cross marker (Reference Point)
    function createCrossMarkerAtPosition(position, cameraPosition) {
        const distance = position.distanceTo(cameraPosition);
        const referenceDistance = 5.0; // Adjust as needed - distance at which base size is used
        const scaleFactor = (distance / referenceDistance); // Scale proportionally to distance

        const currentCrossSize = baseCrossSize * scaleFactor;
        const currentCrossThickness = currentCrossSize * crossThicknessRatio;

        // Create geometry with the calculated size
        // Use separate geometries for each arm to allow individual clicking
        const dynamicCrossGeometryX = new THREE.BoxGeometry(currentCrossSize, currentCrossThickness, currentCrossThickness);
        const dynamicCrossGeometryY = new THREE.BoxGeometry(currentCrossThickness, currentCrossSize, currentCrossThickness); // Adjusted for Y axis
        const dynamicCrossGeometryZ = new THREE.BoxGeometry(currentCrossThickness, currentCrossThickness, currentCrossSize); // Adjusted for Z axis


        const crossGroup = new THREE.Group();

        // X-axis arm (Red)
        const crossMeshX = new THREE.Mesh(dynamicCrossGeometryX, crossMaterialX);
        crossMeshX.name = 'crossX'; // Assign name

        // Y-axis arm (Green)
        const crossMeshY = new THREE.Mesh(dynamicCrossGeometryY, crossMaterialY);
        // No rotation needed due to adjusted geometry
        crossMeshY.name = 'crossY'; // Assign name

        // Z-axis arm (Blue)
        const crossMeshZ = new THREE.Mesh(dynamicCrossGeometryZ, crossMaterialZ);
        // No rotation needed due to adjusted geometry
        crossMeshZ.name = 'crossZ'; // Assign name

        crossGroup.add(crossMeshX);
        crossGroup.add(crossMeshY);
        crossGroup.add(crossMeshZ);

        // No need to scale the group, as geometry size is dynamic
        crossGroup.position.copy(position);
        crossGroup.userData.isReferencePoint = true;
        crossGroup.userData.originalPosition = position.clone(); // Store initial position if needed later
        markerGroup.add(crossGroup); // Add to the main marker group

        // Set camera target to the new anchor position
        controls.target.copy(position);

        // Maintain camera distance
        const offset = new THREE.Vector3().subVectors(camera.position, position);
        camera.position.copy(position).add(offset);
        controls.update();


        console.log(`Reference Point added at: ${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)} with scale factor ${scaleFactor.toFixed(2)} (dist: ${distance.toFixed(2)})`);

        // Dispose of dynamic geometry
        dynamicCrossGeometryX.dispose();
        dynamicCrossGeometryY.dispose();
        dynamicCrossGeometryZ.dispose();
        // Note: DragControls automatically updates its list when children are added to markerGroup
    }

    // --- Double Click Listener (for placing points ONLY) ---

    // --- Double Click Listener (for placing points ONLY) ---
    renderer.domElement.addEventListener('dblclick', onDoubleClickPlacePoint, false); // Renamed

    function onDoubleClickPlacePoint(event) { // Renamed and simplified
        event.preventDefault();

        // 1. Check if the click is on the UI panel first.
        const containerRect = document.getElementById('container').getBoundingClientRect();
        if (event.clientX >= containerRect.left && event.clientX <= containerRect.right &&
            event.clientY >= containerRect.top && event.clientY <= containerRect.bottom) {
            return; // Click is inside the UI panel
        }

        // 2. If measuring, finish measurement.
        if (measurementState === 'measuring') {
            finishMeasurement(false); // Finish as open path
            console.log("Measurement finished by double-click (on non-marker or empty space).");
            return; // Stop further processing
        }

        // 3. If idle & not UI: Place new point.
        // --- Raycast against splats to place a NEW point ---
        if (splatMeshes.length === 0) {
            console.log("No splats loaded for placing point on double-click.");
            return;
        }

        // Use standard THREE.js raycasting with the new SplatMesh - following the example
        const rect = renderer.domElement.getBoundingClientRect();
        const clickCoords = new THREE.Vector2(
            (event.clientX / rect.width) * 2 - 1,
            -(event.clientY / rect.height) * 2 + 1
        );
        
        clickRaycaster.setFromCamera(clickCoords, camera);
        
        // Raycast against all loaded splat meshes
        const hits = clickRaycaster.intersectObjects(splatMeshes);
        
        if (hits.length > 0) {
            const hitPosition = hits[0].point;
            createCrossMarkerAtPosition(hitPosition, camera.position);
        } else {
            console.log("No splat hit on double-click (for new point placement).");
        }
    }

    // --- Click Listener (Refactored for measurements, scale setting, AND Gizmo Activation) ---
    function onClick(event) {
        event.preventDefault();
        console.log(`onClick triggered. Measurement State: ${measurementState}, Transform Mode: ${transformModeActive}`); // Log state

        // 1. Ignore if dragging marker or gizmo
        if (draggedObject || transformControls.dragging) {
            console.log("onClick ignored: Drag in progress.");
            return;
        }

        // 2. Ignore if clicking UI panel
        const containerRect = document.getElementById('container').getBoundingClientRect();
        if (event.clientX >= containerRect.left && event.clientX <= containerRect.right &&
            event.clientY >= containerRect.top && event.clientY <= containerRect.bottom) {
            console.log("onClick ignored: UI panel.");
            return; // Click is inside the UI panel
        }

        // --- Raycasting Setup ---
        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );
        clickRaycaster.setFromCamera(mouse, camera);

        // --- Interaction Checks (Prioritized) ---

        // 3. Check Label Click (Scaling) - Only if idle
        let labelHit = false;
        if (measurementState === 'idle') {
            const intersectsLabels = clickRaycaster.intersectObjects(measurementGroup.children, true)
                .filter(intersect => intersect.object.userData && intersect.object.userData.isDistanceLabel);
            if (intersectsLabels.length > 0) {
                labelHit = true;
                console.log("onClick: Label clicked.");
                setReferenceScale(intersectsLabels[0].object);
                deactivateTransformMode(); // Deactivate transform mode if a label is clicked
                return; // Label click handled
            }
        }
        console.log(`onClick: Label hit? ${labelHit} (State: ${measurementState})`);

        // 4. Check Marker Click (Measurement Start/Continue)
        const intersectsMarkers = clickRaycaster.intersectObjects(markerGroup.children, true);
        let clickedMarker = null;
        if (intersectsMarkers.length > 0) {
            let obj = intersectsMarkers[0].object;
            while (obj && !obj.userData.isReferencePoint) {
                obj = obj.parent;
            }
            if (obj && obj.userData.isReferencePoint) {
                clickedMarker = obj;
            }
        }
        console.log(`onClick: Marker hit? ${!!clickedMarker}`);

        if (clickedMarker) {
            console.log("onClick: Marker interaction.");
            if (measurementState === 'idle') {
                startMeasurement(clickedMarker);
                deactivateTransformMode(); // Deactivate transform mode when starting measurement
            } else if (measurementState === 'measuring') {
                addPointToMeasurement(clickedMarker);
                // Transform mode should already be deactivated here
            }
            return; // Marker click handled
        }

        // --- If not label or marker, check splat or empty space ---

        // 5. Check Splat Click (Gizmo Activation / Measurement Cancel)
        let splatHit = false;
        let hitSplatObject = null; // To store the specific splat that was hit
        if (splatMeshes.length > 0) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((event.clientX - rect.left) / rect.width) * 2 - 1,
                -((event.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            clickRaycaster.setFromCamera(mouse, camera);
            try {
                // Intersect with all splat meshes in the scene
                const intersects = clickRaycaster.intersectObjects(splatMeshes);
                if (intersects.length > 0) {
                    splatHit = true;
                    hitSplatObject = intersects[0].object; // Get the specific splat mesh that was hit
                }
            } catch (e) {
                console.warn("Error raycasting against splat meshes:", e);
                splatHit = false;
            }
        }
        console.log(`onClick: Splat hit? ${splatHit}`);

        if (splatHit) {
            console.log("onClick: Splat interaction.");
            // If measuring, cancel the measurement first
            if (measurementState === 'measuring') {
                console.log("onClick: Splat clicked while measuring. Cancelling measurement.");
                resetMeasurementState(); // Cancel measurement
            }

            // Only attach gizmo if transform mode is active
            if (transformModeActive) {
                const shouldAttach = transformControls.object !== hitSplatObject;
                console.log(`onClick: Should attach gizmo (Transform Mode Active)? ${shouldAttach}`);
                if (shouldAttach) {
                    transformControls.attach(hitSplatObject);
                    transformControls.visible = true;
                    transformControls.enabled = true;
                    updateTransformModeButtons(transformControls.getMode()); // Update buttons on attach
                    console.log("onClick: Gizmo attached to splat mesh.");
                }
                // If already attached, clicking the splat again does nothing (keeps it attached)
            } else {
                 console.log("onClick: Splat clicked, but Transform Mode is not active. Gizmo not attached.");
                 // Optionally detach if clicking splat while mode is off? For now, do nothing.
                 // detachGizmo();
            }
            return; // Splat click handled
        }

        // 6. Clicked on Empty Space (Gizmo Detach / Measurement Cancel)
        // This block is reached if it wasn't UI, label, marker, or splat
        console.log("onClick: Empty space interaction.");
        // If measuring, cancel the measurement first
        if (measurementState === 'measuring') {
            console.log("onClick: Empty space clicked while measuring. Cancelling measurement.");
            resetMeasurementState(); // Cancel measurement
        }
        // Detach the gizmo (state is guaranteed to be 'idle')
        // Also deactivate transform mode when clicking empty space
        deactivateTransformMode(); // Detach gizmo AND deactivate mode
    }

    // --- Right Click Listener (for deleting measurements) ---
    function onRightClick(event) {
        event.preventDefault();

        // ADD THIS CHECK AT THE TOP:
        if (rightMouseDragHappened) {
            console.log("onRightClick (contextmenu) ignored: Right mouse drag detected.");
            // No need to reset rightMouseDragHappened here,
            // it will be reset on the next right 'pointerdown' event.
            return;
        }

        // Ignore if dragging marker or gizmo
        if (draggedObject || (transformControls && transformControls.dragging)) {
            console.log("onRightClick ignored: Drag in progress.");
            return;
        }

        // Ignore if clicking UI panel
        const containerRect = document.getElementById('container').getBoundingClientRect();
        if (event.clientX >= containerRect.left && event.clientX <= containerRect.right &&
            event.clientY >= containerRect.top && event.clientY <= containerRect.bottom) {
            console.log("onRightClick ignored: UI panel.");
            return;
        }

        const mouse = new THREE.Vector2(
            (event.clientX / window.innerWidth) * 2 - 1,
            -(event.clientY / window.innerHeight) * 2 + 1
        );
        clickRaycaster.setFromCamera(mouse, camera);

        // 1. Check for Reference Point (Anchor/Cross Marker) click
        const intersectsMarkers = clickRaycaster.intersectObjects(markerGroup.children, true);
        if (intersectsMarkers.length > 0) {
            const intersectedObject = intersectsMarkers[0].object;
            if (intersectedObject.parent && intersectedObject.parent.userData.isReferencePoint) {
                const crossToRemove = intersectedObject.parent;
                const removedPosition = crossToRemove.position.clone(); // Get position before removing from scene
                markerGroup.remove(crossToRemove);
                console.log("Reference Point removed by right-click.");

                // IMPROVEMENT: Clean up associated measurements
                cleanupMeasurementsForPosition(removedPosition);

                // If a measurement was active, reset it, as one of its points is now gone.
                if (measurementState === 'measuring') {
                    // Check if the removed marker was part of the current measurement
                    const removedMarkerWasInMeasurement = currentMeasurementSequence.some(p => p.marker === crossToRemove);
                    if (removedMarkerWasInMeasurement) {
                        console.log("Measurement cancelled because an active reference point was deleted.");
                        resetMeasurementState();
                    }
                }
                return; // Marker deleted, action complete.
            }
        }

        // 2. Check for Measurement Label click (if no marker was clicked)
        const intersectsLabels = clickRaycaster.intersectObjects(measurementGroup.children, true);
        for (const intersect of intersectsLabels) {
            const clickedObject = intersect.object;
            if (clickedObject.userData && clickedObject.userData.isDistanceLabel && clickedObject.userData.associatedLine) {
                const labelToRemove = clickedObject;
                const lineToRemove = clickedObject.userData.associatedLine;

                console.log("Right-clicked on measurement label. Removing measurement segment.");

                // Remove from scene
                measurementGroup.remove(labelToRemove);
                measurementGroup.remove(lineToRemove);

                // Dispose of resources
                if (labelToRemove.material.map && labelToRemove.material.map.dispose) {
                    labelToRemove.material.map.dispose(); // Dispose canvas texture
                }
                if (labelToRemove.material && labelToRemove.material.dispose) {
                    labelToRemove.material.dispose();
                }
                // Sprite geometry is managed by THREE, no explicit disposal needed unless custom

                if (lineToRemove.geometry && lineToRemove.geometry.dispose) {
                    lineToRemove.geometry.dispose();
                }
                if (lineToRemove.material && lineToRemove.material.dispose) {
                    lineToRemove.material.dispose();
                }

                // Clear references in currentMeasurementSequence
                for (const pointData of currentMeasurementSequence) {
                    if (pointData.distanceLabel === labelToRemove) {
                        pointData.distanceLabel = undefined;
                        pointData.segmentLine = undefined;
                        break; 
                    }
                }
                // Also check if the closing segment's label was clicked (if applicable)
                // This part depends on how closing segment labels are stored/referenced.
                // For now, the loop above handles labels stored on endPointData.

                console.log("Measurement segment removed and resources disposed.");
                return; // Found and handled the label
            }
        }
    }


    // --- Pointer Move Listener (for preview line) ---
    function onPointerMove(event) {
        // Update NDC
        currentMouseNDC.x = (event.clientX / window.innerWidth) * 2 - 1;
        currentMouseNDC.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Logic for right mouse drag detection
        if (isRightMouseButtonDown && !rightMouseDragHappened) { // Check !rightMouseDragHappened to avoid redundant calculations
            const dx = Math.abs(event.clientX - rightMouseDownPosition.x);
            const dy = Math.abs(event.clientY - rightMouseDownPosition.y);
            if (dx > rightMouseDragThreshold || dy > rightMouseDragThreshold) {
                rightMouseDragHappened = true;
                // console.log("Right mouse drag detected during pointermove."); // Optional: for debugging
            }
        }
        
        // Ensure clickRaycaster and required objects are initialized
        if (!clickRaycaster || !camera || !renderer || !renderer.domElement) {
            return;
        }

        // Change cursor to pointer when hovering over a distance label in idle state
        let cursorStyle = 'crosshair';
        if (measurementState === 'idle' && measurementGroup) {
            try {
                clickRaycaster.setFromCamera(currentMouseNDC, camera);
                const intersectsLabels = clickRaycaster.intersectObjects(measurementGroup.children, true)
                    .filter(intersect => intersect.object.userData && intersect.object.userData.isDistanceLabel);
                if (intersectsLabels.length > 0) {
                    cursorStyle = 'pointer';
                }
            } catch (e) {
                console.warn("Error checking for label intersections:", e);
            }
        }
        renderer.domElement.style.cursor = cursorStyle;

        // Update preview line only if measuring and hovering over a valid marker
        if (measurementState === 'measuring' && currentMeasurementSequence.length > 0 && markerGroup) {
            try {
                clickRaycaster.setFromCamera(currentMouseNDC, camera);
                const intersectsMarkers = clickRaycaster.intersectObjects(markerGroup.children, true);

                let hoveredMarker = null;
                if (intersectsMarkers.length > 0) {
                    // Find the parent group which is the actual marker
                    let obj = intersectsMarkers[0].object;
                    while (obj && !obj.userData.isReferencePoint) {
                        obj = obj.parent;
                    }
                    // Check if it's a valid marker and not the last one added
                    if (obj && obj.userData.isReferencePoint && obj !== currentMeasurementSequence[currentMeasurementSequence.length - 1].marker) {
                        hoveredMarker = obj;
                    }
                }

                if (hoveredMarker) {
                    updatePreviewLine(hoveredMarker.position); // Pass target position
                } else {
                    updatePreviewLine(null); // Hide preview line
                }
            } catch (e) {
                console.warn("Error in raycasting for measurement preview:", e);
                updatePreviewLine(null); // Ensure preview is hidden on error
            }
        } else {
             updatePreviewLine(null); // Ensure preview is hidden if not measuring
        }
    }

    // --- Key Down Listener ---
    function onKeyDown(event) {
        // Handle gizmo controls if it's attached AND transform mode is active
        if (transformControls.object && transformModeActive) { // Added transformModeActive check
            let newMode = null;
            switch (event.key.toLowerCase()) {
                case 'w': // Translate
                    transformControls.setMode("translate");
                    newMode = 'translate';
                    event.preventDefault();
                    break;
                case 'e': // Rotate
                    transformControls.setMode("rotate");
                    newMode = 'rotate';
                    event.preventDefault();
                    break;
                case 'r': // Scale
                    transformControls.setMode("scale");
                    newMode = 'scale';
                    event.preventDefault();
                    break;
                case 'q': // Toggle World/Local Space
                    transformControls.setSpace(transformControls.space === "local" ? "world" : "local");
                    event.preventDefault();
                    break;
                case 'escape': // Detach Gizmo AND Deactivate Mode
                     // Only act if not measuring
                     if (measurementState === 'idle') {
                         deactivateTransformMode(); // Use helper function
                         event.preventDefault();
                     }
                    break;
            }
            if (newMode) {
                updateTransformModeButtons(newMode); // Update buttons on keyboard mode change
            }
        }

        // Handle measurement controls if measuring
        if (measurementState === 'measuring') {
            switch (event.key) {
                case 'Enter':
                case 'Escape': // ESC also finishes measurement
                    finishMeasurement(false); // Finish as open path
                    event.preventDefault();
                    break;
                case 'Backspace':
                case 'Delete':
                    removeLastMeasurementSegment();
                    event.preventDefault();
                    break;
                case 'ArrowLeft':
                    currentAxisSnap = 'x';
                    console.log("Axis Snap: X");
                    updatePreviewLine(); // Update preview with snap indication
                    event.preventDefault();
                    break;
                case 'ArrowRight': // Using Right Arrow for Z as per spec
                    currentAxisSnap = 'z';
                    console.log("Axis Snap: Z");
                    updatePreviewLine();
                    event.preventDefault();
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                    currentAxisSnap = 'y';
                    console.log("Axis Snap: Y");
                    updatePreviewLine();
                    event.preventDefault();
                    break;
            }
        }
    }

    // --- Measurement Core Functions ---

    function startMeasurement(startMarker) {
        if (measurementState !== 'idle') return;
        measurementState = 'measuring';
        currentMeasurementSequence = [{ point: startMarker.position.clone(), marker: startMarker }];
        measurementColorIndex = (measurementColorIndex + 1) % measurementColors.length;
        currentAxisSnap = null; // Reset axis snap
        console.log("Started measurement sequence.");
        // Initialize preview line immediately
        updatePreviewLine();
    }

    function addPointToMeasurement(nextMarker) {
        if (measurementState !== 'measuring' || currentMeasurementSequence.length === 0) return;

        const startPointInfo = currentMeasurementSequence[currentMeasurementSequence.length - 1];
        const endPoint = nextMarker.position.clone();
        const startPoint = startPointInfo.point;

        // Check if closing the loop
        if (currentMeasurementSequence.length >= 2 && nextMarker === currentMeasurementSequence[0].marker) {
            // Closing the loop
            drawMeasurementSegment(startPoint, currentMeasurementSequence[0].point, currentMeasurementSequence[0].marker); // Draw segment to first point
            finishMeasurement(true); // Finish as closed area
            return;
        }

        // Avoid adding the same point consecutively
        if (nextMarker === startPointInfo.marker) {
            console.log("Cannot add the same point consecutively.");
            return;
        }

        // Draw the segment (potentially with axis snapping)
        drawMeasurementSegment(startPoint, endPoint, nextMarker);

        // Add the new point to the sequence (handled within drawMeasurementSegment if snapping)
        if (!currentAxisSnap) { // Only add if not snapping (snapping adds intermediate points)
             currentMeasurementSequence.push({ point: endPoint, marker: nextMarker });
        }

        currentAxisSnap = null; // Reset axis snap after adding a point
        updatePreviewLine(); // Update preview for the next potential segment
    }

    function drawMeasurementSegment(p1, p2, endMarker) {
        const color = measurementColors[measurementColorIndex];
        let segments = []; // Array to hold {start, end} points for segments

        if (currentAxisSnap) {
            // --- Axis Snapping Logic ---
            let intermediatePoints = [p1.clone()];
            let current = p1.clone();
            const target = p2.clone();
            const delta = target.clone().sub(current);

            // For axis snapping, create orthogonal segments based on which axis was selected
            if (currentAxisSnap === 'x') {
                // Move along X first, then Y, then Z
                let p = current.clone();
                p.x = target.x;  // Move to target X
                if (p.distanceToSquared(current) > 1e-6) intermediatePoints.push(p.clone());
                
                p.y = target.y;  // Then move to target Y
                if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) 
                    intermediatePoints.push(p.clone());
                
                p.z = target.z;  // Then move to target Z
                if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) 
                    intermediatePoints.push(p.clone());
            } 
            else if (currentAxisSnap === 'y') {
                // Move along Y first, then X, then Z
                let p = current.clone();
                p.y = target.y;  // Move to target Y
                if (p.distanceToSquared(current) > 1e-6) intermediatePoints.push(p.clone());
                
                p.x = target.x;  // Then move to target X
                if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) 
                    intermediatePoints.push(p.clone());
                
                p.z = target.z;  // Then move to target Z
                if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) 
                    intermediatePoints.push(p.clone());
            }
            else if (currentAxisSnap === 'z') {
                // Move along Z first, then X, then Y
                let p = current.clone();
                p.z = target.z;  // Move to target Z
                if (p.distanceToSquared(current) > 1e-6) intermediatePoints.push(p.clone());
                
                p.x = target.x;  // Then move to target X
                if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) 
                    intermediatePoints.push(p.clone());
                
                p.y = target.y;  // Then move to target Y
                if (p.distanceToSquared(intermediatePoints[intermediatePoints.length-1]) > 1e-6) 
                    intermediatePoints.push(p.clone());
            }

            // Create segments from intermediate points
            for (let i = 0; i < intermediatePoints.length - 1; i++) {
                segments.push({ start: intermediatePoints[i], end: intermediatePoints[i+1] });
            }

            // Add intermediate points and final point to sequence
            // Skip the very first point (p1) as it's already there
            for (let i = 1; i < intermediatePoints.length; i++) {
                 // Use the endMarker only for the very last point added by snapping
                 const markerForPoint = (i === intermediatePoints.length - 1) ? endMarker : null;
                 currentMeasurementSequence.push({ point: intermediatePoints[i], marker: markerForPoint });
            }

        } else {
            // --- No Axis Snapping ---
            segments.push({ start: p1, end: p2 });
            // The calling function (addPointToMeasurement) will add p2 to the sequence
        }

        // --- Draw Lines and Labels for each segment ---
        segments.forEach(seg => {
            const distance = seg.start.distanceTo(seg.end) * scaleFactor;
            if (distance < 1e-6) return; // Skip zero-length segments

            const geometry = new THREE.BufferGeometry().setFromPoints([seg.start, seg.end]);
            const material = new THREE.LineBasicMaterial({ color: color, linewidth: 2 }); // Linewidth might not work on all systems
            const line = new THREE.Line(geometry, material);
            line.userData.isMeasurementLine = true;
            line.userData.colorIndex = measurementColorIndex; // Store color index
            measurementGroup.add(line);

            const label = createDistanceLabel(distance.toFixed(2), color); // Use scaleFactor
            label.position.copy(seg.start).lerp(seg.end, 0.5); // Position at midpoint
            label.userData.isDistanceLabel = true;
            label.userData.segmentStart = seg.start.clone(); // Store segment points for scaling
            label.userData.segmentEnd = seg.end.clone();
            label.userData.colorIndex = measurementColorIndex;
            measurementGroup.add(label);

            // Link line and label for easy removal
            line.userData.associatedLabel = label;
            label.userData.associatedLine = line;
            line.userData.isSegmentLine = true;

            // Associate line and label with the *starting* point of this segment in the sequence
            // Find the sequence entry corresponding to seg.start
             const sequenceEntry = currentMeasurementSequence.find(entry => entry.point.equals(seg.start));
             if (sequenceEntry) {
                 if (!sequenceEntry.segments) sequenceEntry.segments = [];
                 sequenceEntry.segments.push({ line: line, label: label });
             } else {
                 console.warn("Could not find sequence entry for segment start:", seg.start);
                 // Fallback: associate with the last entry (less accurate for snapping)
                 const lastEntry = currentMeasurementSequence[currentMeasurementSequence.length - 1];
                 if (!lastEntry.segments) lastEntry.segments = [];
                 lastEntry.segments.push({ line: line, label: label });
             }
        });
    }

    function finishMeasurement(closed) {
        if (measurementState !== 'measuring' || currentMeasurementSequence.length < (closed ? 3 : 2)) {
            // Need at least 3 points for area, 2 for path
            console.log("Not enough points to finish measurement.");
            resetMeasurementState();
            return;
        }

        const color = measurementColors[measurementColorIndex];
        let totalLength = 0;
        let lastPoint = currentMeasurementSequence[0].point;

        // Calculate total length by summing segment distances associated with points
        for (let i = 0; i < currentMeasurementSequence.length; i++) {
            const entry = currentMeasurementSequence[i];
            if (entry.segments) {
                entry.segments.forEach(segData => {
                    // Extract distance from label text (assuming format "value")
                    const dist = parseFloat(segData.label.userData.text);
                    if (!isNaN(dist)) {
                        totalLength += dist;
                    }
                });
            }
        }


        if (closed) {
            // --- Calculate Area ---
            const points2D = projectPointsToPlane(currentMeasurementSequence.map(p => p.point));
            const area = calculatePolygonArea(points2D) * (scaleFactor * scaleFactor); // Apply scale factor squared for area

            if (area > 1e-6) {
                const areaLabel = createDistanceLabel(`Area: ${area.toFixed(2)}`, color, 14); // Slightly larger font for area
                // Calculate centroid for label position
                const centroid = new THREE.Vector3();
                currentMeasurementSequence.forEach(p => centroid.add(p.point));
                centroid.divideScalar(currentMeasurementSequence.length);
                areaLabel.position.copy(centroid);
                areaLabel.userData.isAreaLabel = true;
                areaLabel.userData.polygonPoints = currentMeasurementSequence.map(p => p.point.clone()); // Store points for rescaling
                areaLabel.userData.colorIndex = measurementColorIndex;
                measurementGroup.add(areaLabel);
                // Store area label reference (e.g., with the first point)
                currentMeasurementSequence[0].areaLabel = areaLabel;
            }
             console.log(`Finished measurement (Closed Area): ${area.toFixed(2)}, Total Length: ${totalLength.toFixed(2)}`);

        } else {
             console.log(`Finished measurement (Open Path): Total Length: ${totalLength.toFixed(2)}`);
             // Optionally add a "Total Length" label at the end point?
        }


        resetMeasurementState();
    }

    function resetMeasurementState() {
        measurementState = 'idle';
        currentMeasurementSequence = [];
        currentAxisSnap = null;
        if (previewLine) {
            measurementGroup.remove(previewLine);
            // Dispose geometry and material if they exist
            if (previewLine.geometry) previewLine.geometry.dispose();
            if (previewLine.material) previewLine.material.dispose();
            previewLine = null;
        }
        console.log("Measurement state reset to idle."); // Updated log message
        // Do NOT deactivate transform mode here, only when explicitly done or interacting elsewhere
    }

    function removeLastMeasurementSegment() {
        if (measurementState !== 'measuring' || currentMeasurementSequence.length <= 1) {
             // If only the start point exists, cancel the measurement
             if (currentMeasurementSequence.length === 1) {
                 resetMeasurementState();
             }
             return;
        }

        // Find the last entry that has segment data associated with it
        let entryToRemoveSegmentsFrom = null;
        for (let i = currentMeasurementSequence.length - 1; i >= 0; i--) {
            if (currentMeasurementSequence[i].segments && currentMeasurementSequence[i].segments.length > 0) {
                entryToRemoveSegmentsFrom = currentMeasurementSequence[i];
                break;
            }
        }

        if (!entryToRemoveSegmentsFrom) {
             console.warn("Could not find previous entry with segments to remove.");
             // As a fallback, just remove the last point added?
             currentMeasurementSequence.pop();
             updatePreviewLine();
             return;
        }


        // Remove the last segment (line and label) associated with that entry
        const lastSegmentData = entryToRemoveSegmentsFrom.segments.pop();
        if (lastSegmentData) {
            measurementGroup.remove(lastSegmentData.line);
            measurementGroup.remove(lastSegmentData.label);
            lastSegmentData.line.geometry.dispose();
            lastSegmentData.line.material.dispose();
            disposeLabel(lastSegmentData.label); // Helper to dispose canvas/texture
        }

        // Remove the point(s) added by the last operation (could be multiple if snapped)
        // Find the index of the entry we just modified
        const startIndexToRemove = currentMeasurementSequence.indexOf(entryToRemoveSegmentsFrom);

        // Remove all points *after* this entry, as they were part of the removed segment(s)
        if (startIndexToRemove < currentMeasurementSequence.length -1) {
             currentMeasurementSequence.splice(startIndexToRemove + 1);
        }


        console.log("Removed last measurement segment/point(s).");
        updatePreviewLine(); // Update preview from the new last point
    }

    // Modified to accept an optional target point
    function updatePreviewLine(targetPoint = null) { // Default to null
        // Hide and return if no target point or not measuring
        if (!targetPoint || measurementState !== 'measuring' || currentMeasurementSequence.length === 0) {
            if (previewLine) {
                previewLine.visible = false; // Just hide, reuse geometry/material
            }
            return;
        }

        const lastPoint = currentMeasurementSequence[currentMeasurementSequence.length - 1].point;
        const color = measurementColors[measurementColorIndex];

        // Apply axis snapping preview if active, using the targetPoint from hover
        let previewEndPoint = targetPoint.clone(); // Start with the hovered marker's position
        if (currentAxisSnap) {
             const delta = previewEndPoint.clone().sub(lastPoint); // Vector from last point to target
             previewEndPoint = lastPoint.clone(); // Start preview from last point

             // Project delta onto the snapped axis/axes (simplified example for single axis)
             // A more complex version would handle multi-segment snapping preview
             if (currentAxisSnap === 'x') {
                 previewEndPoint.x += delta.x;
             } else if (currentAxisSnap === 'y') {
                 previewEndPoint.y += delta.y;
             } else if (currentAxisSnap === 'z') {
                 previewEndPoint.z += delta.z;
             }
             // Note: This simplified preview for snapping shows a direct line along the snapped axis's delta component.
             // A full preview of the multi-segment snapped path is more complex.
        }


        if (!previewLine) {
            const geometry = new THREE.BufferGeometry().setFromPoints([lastPoint, previewEndPoint]);
            const material = new THREE.LineDashedMaterial({
                color: color,
                linewidth: 1,
                scale: 1,
                dashSize: 0.1,
                gapSize: 0.05,
            });
            previewLine = new THREE.Line(geometry, material);
            previewLine.computeLineDistances(); // Important for dashed lines
            measurementGroup.add(previewLine);
        } else {
            previewLine.geometry.setFromPoints([lastPoint, previewEndPoint]);
            previewLine.geometry.attributes.position.needsUpdate = true;
            previewLine.computeLineDistances(); // Recompute for dashed lines
            previewLine.material.color.setHex(color); // Ensure color is correct
            previewLine.visible = true; // Make sure it's visible
        }
    }

    // --- Helper Functions ---

    function createDistanceLabel(text, colorHex, fontSize = 12) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        context.font = `Bold ${fontSize}px Arial`; // Use Arial or sans-serif

        // Measure text width for canvas sizing
        const textMetrics = context.measureText(text);
        const textWidth = textMetrics.width;
        const padding = 8; // Add padding

        canvas.width = textWidth + padding * 2;
        canvas.height = fontSize + padding * 2; // Adjust height based on font size and padding

        // Re-apply font after resizing canvas (important!)
        context.font = `Bold ${fontSize}px Arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';

        // Background
        context.fillStyle = `#${colorHex.toString(16).padStart(6, '0')}`; // Use hex color for background
        context.globalAlpha = 0.7; // Semi-transparent background
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.globalAlpha = 1.0; // Reset alpha

        // Text
        context.fillStyle = '#ffffff'; // White text
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false, depthWrite: false });
        const sprite = new THREE.Sprite(material);

        // Scale sprite based on canvas aspect ratio to avoid distortion
        const aspect = canvas.width / canvas.height;
        sprite.scale.set(0.05 * aspect, 0.05, 1); // Adjust base scale (0.2) as needed

        sprite.renderOrder = 1; // Render labels on top
        sprite.userData.text = text; // Store text for potential updates/parsing

        return sprite;
    }

    function disposeLabel(labelSprite) {
        if (labelSprite && labelSprite.material) {
            if (labelSprite.material.map) {
                labelSprite.material.map.dispose();
            }
            labelSprite.material.dispose();
        }
        // Geometry is implicitly handled for Sprites
    }

    function projectPointsToPlane(points) {
        // More robust plane calculation that finds the best-fit plane
        if (points.length < 3) return [];
        
        // Find the normal of the best-fit plane
        // For simplicity, we'll use the cross product of two edges
        // A more robust solution would use PCA or SVD
        const v1 = new THREE.Vector3().subVectors(points[1], points[0]);
        const v2 = new THREE.Vector3().subVectors(points[2], points[0]);
        const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
        
        // If the normal is close to zero, fall back to XY projection
        if (normal.lengthSq() < 0.1) {
            return points.map(p => new THREE.Vector2(p.x, p.y));
        }
        
        // Find the most aligned world axis to project onto
        const absX = Math.abs(normal.x);
        const absY = Math.abs(normal.y);
        const absZ = Math.abs(normal.z);
        
        let projectedPoints;
        if (absZ >= absX && absZ >= absY) {
            // Project onto XY plane
            projectedPoints = points.map(p => new THREE.Vector2(p.x, p.y));
        } else if (absY >= absX && absY >= absZ) {
            // Project onto XZ plane
            projectedPoints = points.map(p => new THREE.Vector2(p.x, p.z));
        } else {
            // Project onto YZ plane
            projectedPoints = points.map(p => new THREE.Vector2(p.y, p.z));
        }
        
        return projectedPoints;
    }

    function calculatePolygonArea(points2D) {
        // Shoelace formula for polygon area
        let area = 0;
        for (let i = 0; i < points2D.length; i++) {
            const j = (i + 1) % points2D.length;
            area += points2D[i].x * points2D[j].y;
            area -= points2D[j].x * points2D[i].y;
        }
        return Math.abs(area / 2);
    }

    function setReferenceScale(clickedLabel) {
        const currentText = clickedLabel.userData.text;
        const currentValue = parseFloat(currentText); // Extract numeric value

        if (isNaN(currentValue) || !clickedLabel.userData.segmentStart || !clickedLabel.userData.segmentEnd) {
            console.error("Invalid label data for scaling.");
            return;
        }

        const newScaleInput = prompt(`Set reference distance for this segment (current: ${currentValue.toFixed(2)}):`, currentValue.toFixed(2));
        if (newScaleInput === null) return; // User cancelled

        const newReferenceValue = parseFloat(newScaleInput);
        if (isNaN(newReferenceValue) || newReferenceValue <= 0) {
            alert("Invalid reference distance. Please enter a positive number.");
            return;
        }

        // Calculate the original Three.js distance for this segment
        const originalDistance = clickedLabel.userData.segmentStart.distanceTo(clickedLabel.userData.segmentEnd);

        if (originalDistance < 1e-6) {
             alert("Cannot set scale based on a zero-length segment.");
             return;
        }

        // Calculate the new global scale factor
        scaleFactor = newReferenceValue / originalDistance;

        console.log(`New scale factor set: ${scaleFactor}`);
        updateAllMeasurementLabels(); // Update all existing labels
    }

    function updateAllMeasurementLabels() {
        // Create a temporary array of children to iterate over to avoid issues with modification during loop
        const childrenToUpdate = [...measurementGroup.children];

        childrenToUpdate.forEach(child => {
            // Guard against child being removed from another operation in the same loop
            if (!child.parent) return;

            if (child.userData.isDistanceLabel && child.userData.segmentStart && child.userData.segmentEnd) {
                const originalDistance = child.userData.segmentStart.distanceTo(child.userData.segmentEnd);
                const scaledDistance = originalDistance * scaleFactor;
                const newText = scaledDistance.toFixed(2);
                
                const colorIndex = child.userData.colorIndex ?? 0;
                const newLabel = createDistanceLabel(newText, measurementColors[colorIndex]);
                newLabel.position.copy(child.position);
                newLabel.userData = { ...child.userData }; // Copy user data
                newLabel.userData.text = newText;

                // Also update the associated line's data if needed (not strictly necessary but good practice)
                if (newLabel.userData.associatedLine) {
                    newLabel.userData.associatedLine.userData.associatedLabel = newLabel;
                }

                measurementGroup.remove(child);
                disposeLabel(child);
                measurementGroup.add(newLabel);

            } else if (child.userData.isAreaLabel && child.userData.polygonPoints) {
                // IMPROVEMENT: Area label found, recalculate area
                const points = child.userData.polygonPoints;
                const points2D = projectPointsToPlane(points);
                const newArea = calculatePolygonArea(points2D) * (scaleFactor * scaleFactor);
                const newText = `Area: ${newArea.toFixed(2)}`;

                const colorIndex = child.userData.colorIndex ?? 0;
                const newLabel = createDistanceLabel(newText, measurementColors[colorIndex], 14);
                newLabel.position.copy(child.position);
                newLabel.userData = { ...child.userData }; // Copy user data
                newLabel.userData.text = newText;

                measurementGroup.remove(child);
                disposeLabel(child);
                measurementGroup.add(newLabel);
            }
        });
    }

    function clearAll() {
        if (!confirm("Are you sure you want to clear all splats, points, and measurements? This cannot be undone.")) return;

        // 1. Clear Splats
        while (splatMeshes.length > 0) {
            const splat = splatMeshes.pop();
            scene.remove(splat);
            // The splat mesh should have a dispose method if the library is well-written
            if (splat.dispose) {
                splat.dispose();
            }
        }
        console.log("All splat meshes cleared.");

        // 2. Clear points and measurements (use existing functions without confirmation)
        clearReferencePoints(false); 
        clearMeasurements(false); 

        // 3. Ensure gizmo is detached (already handled by clear functions which call deactivateTransformMode)
    }

    function clearReferencePoints(askConfirmation = true) {
        let confirmed = !askConfirmation;
        if (askConfirmation) {
            confirmed = confirm("Are you sure you want to clear ALL reference points? This will also remove connected measurements.");
        }

        if (confirmed) {
            // Create a copy of children to iterate over, as the group will be modified.
            [...markerGroup.children].forEach(marker => {
                const removedPosition = marker.position.clone();
                markerGroup.remove(marker);
                cleanupMeasurementsForPosition(removedPosition); // Clean up associated measurements
            });

            console.log("All reference points and connected measurements cleared.");
            deactivateTransformMode();
        }
    }

    function clearMeasurements(askConfirmation = true) {
         let confirmed = !askConfirmation;
         if (askConfirmation) {
             confirmed = confirm("Are you sure you want to clear ALL measurements? This cannot be undone.");
         }

        if (confirmed) {
            // Remove lines and labels from the measurement group
            const toRemove = [];
            measurementGroup.children.forEach(child => {
                 if (child.userData.isMeasurementLine || child.userData.isDistanceLabel || child.userData.isAreaLabel || child === previewLine) {
                     toRemove.push(child);
                 }
            });

            toRemove.forEach(child => {
                measurementGroup.remove(child);
                if (child.isLine) {
                    child.geometry.dispose();
                    child.material.dispose();
                } else if (child.isSprite) {
                    disposeLabel(child);
                }
            });

            resetMeasurementState(); // Ensure state is idle
            console.log("All measurements cleared.");
            deactivateTransformMode();
        }
    }

    // IMPROVEMENT: Helper to clean up measurements if a point is deleted
    function cleanupMeasurementsForPosition(position) {
        const linesToRemove = [];
        const labelsToRemove = new Set(); // Use a Set to avoid duplicates

        measurementGroup.children.forEach(child => {
            if (child.userData.isMeasurementLine && child.geometry) {
                const pos = child.geometry.attributes.position;
                if (!pos || pos.count < 2) return;

                const p1 = new THREE.Vector3().fromBufferAttribute(pos, 0);
                const p2 = new THREE.Vector3().fromBufferAttribute(pos, 1);
                
                // Use a small epsilon for floating point comparison
                if (p1.distanceToSquared(position) < 1e-6 || p2.distanceToSquared(position) < 1e-6) {
                    linesToRemove.push(child);
                    if (child.userData.associatedLabel) {
                        labelsToRemove.add(child.userData.associatedLabel);
                    }
                }
            }
        });

        if (linesToRemove.length > 0) {
            console.log(`Removing ${linesToRemove.length} measurement segment(s) connected to deleted point.`);
            linesToRemove.forEach(line => {
                measurementGroup.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            });
            labelsToRemove.forEach(label => {
                measurementGroup.remove(label);
                disposeLabel(label);
            });
        }
    }


    // --- Click-to-Spawn Reference Point Feature ---
    // The redundant code has been removed (duplicate createCrossMarkerAtPosition function and other duplicated code)
    
  </script>
</body>
</html>